<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PewPi — Decrypt & Activate (chat-ready)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071722;color:#e9fbff}
  .wrap{max-width:880px;margin:0 auto}
  .card{background:#08242f;padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
  input,textarea,button{font:inherit}
  input,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
  textarea{min-height:120px;resize:vertical;font-family:monospace}
  .row{display:flex;gap:8px;margin-top:8px}
  button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
  .status{margin-top:10px;color:#cfeee6}
  pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto}
  .console{border:1px solid rgba(255,255,255,0.03);padding:10px;border-radius:8px;background:#041016;min-height:220px;white-space:pre-wrap;overflow:auto}
  .msg-user{color:#9be0ff;font-weight:700;margin-bottom:6px}
  .msg-rogers{color:#b9ffd9;margin-bottom:6px}
  .small{font-size:0.9rem;color:#9bb7c2}
</style>
</head>
<body>
  <div class="wrap">
    <h1>PewPi — Decrypt & Activate (chat-ready)</h1>

    <div class="card">
      <div class="small">Paste the ciphertext JSON you committed (secrets.json) and the passphrase you used when encrypting. Click Decrypt → Load token to enable Rogers. The passphrase never leaves your browser.</div>

      <label style="margin-top:8px">Passphrase</label>
      <div class="row">
        <input id="pass" type="password" placeholder="Enter passphrase used to encrypt" />
        <button id="decryptBtn">Decrypt</button>
      </div>

      <label style="margin-top:8px">Ciphertext JSON (paste the exact JSON you committed)</label>
      <textarea id="blob" placeholder='Paste the ciphertext JSON object here (e.g. contents of secrets.json)'></textarea>

      <div class="row">
        <button id="loadPaste" class="secondary">Load from clipboard</button>
        <button id="clearAll" class="secondary">Clear</button>
      </div>

      <div id="status" class="status">Ready. Paste blob and enter passphrase, then Decrypt.</div>
    </div>

    <div class="card" id="plainCard" style="display:block">
      <label style="margin-top:8px">Decrypted plaintext</label>
      <pre id="plain">{ nothing decrypted yet }</pre>
      <div class="row" style="margin-top:8px">
        <button id="loadToken" class="secondary">Load github_token into session</button>
        <button id="copyPlain" class="secondary">Copy plaintext</button>
      </div>
      <div class="small" style="margin-top:8px">If the decrypted JSON contains secrets.github_token, Load github_token will put it into sessionStorage as gh.token. Your Rogers chat below will use that token for private repo fetches.</div>
    </div>

    <div class="card" id="chatCard" style="display:none">
      <label style="font-weight:700">Rogers — Chat</label>
      <div id="console" class="console"></div>

      <div class="row" style="margin-top:8px">
        <input id="query" placeholder='Type message (example: "hello" or "fetch github owner repo path")' />
        <button id="send">Send</button>
        <button id="clearConsole" class="secondary">Clear</button>
      </div>

      <div id="console_status" class="status">Rogers inactive until token/load step completes (or you can still use public fetches).</div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="small">When you're done, click Clear to remove sensitive data from the page, and revoke your PAT in GitHub if you created one for use. This file runs fully in-browser; no secrets are sent anywhere.</div>
    </div>
  </div>

<script>
/* Minimal WebCrypto AES-GCM + PBKDF2 decryption
   PBKDF2 iterations = 250000, hash = SHA-256
*/
function id(n){ return document.getElementById(n); }
function setStatus(s){ id('status').textContent = s; }

function b64ToU8(s){
  const bin = atob(s);
  const u = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i);
  return u;
}

async function deriveKey(pass, saltU8){
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: saltU8, iterations: 250000, hash: 'SHA-256' },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}

async function decryptBlobJson(blobJson, pass){
  if(!blobJson || !blobJson.ct) throw new Error('Invalid ciphertext blob (missing ct field)');
  const saltU8 = b64ToU8(blobJson.salt);
  const ivU8 = b64ToU8(blobJson.iv);
  const ctU8 = b64ToU8(blobJson.ct);
  const key = await deriveKey(pass, saltU8);
  const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, key, ctU8.buffer);
  return JSON.parse(new TextDecoder().decode(pt));
}

/* UI wiring: clipboard load / clear */
id('loadPaste').addEventListener('click', async ()=>{
  try{
    const text = await navigator.clipboard.readText();
    id('blob').value = text;
    setStatus('Loaded clipboard into blob textarea.');
  }catch(e){
    setStatus('Clipboard read failed: ' + (e && e.message ? e.message : e));
  }
});

id('clearAll').addEventListener('click', ()=>{
  id('blob').value = '';
  id('pass').value = '';
  id('plain').textContent = '{ nothing decrypted yet }';
  sessionStorage.removeItem('gh.token');
  id('chatCard').style.display = 'none';
  setStatus('Cleared. Token removed from session.');
});

/* decrypt button */
id('decryptBtn').addEventListener('click', async ()=>{
  const pass = id('pass').value;
  const txt = id('blob').value.trim();
  if(!txt){ setStatus('Paste the ciphertext JSON.'); return; }
  if(!pass){ setStatus('Enter passphrase.'); return; }

  setStatus('Parsing blob JSON...');
  let blob = null;
  try{
    blob = JSON.parse(txt);
  }catch(e){
    const m = txt.match(/\{[\s\S]*\}/);
    if(m) {
      try { blob = JSON.parse(m[0]); } catch(err){ blob = null; }
    }
  }
  if(!blob){ setStatus('Invalid JSON. Paste the exact ciphertext JSON you committed.'); return; }

  setStatus('Decrypting (in-browser)...');
  try{
    const plain = await decryptBlobJson(blob, pass);
    id('plain').textContent = JSON.stringify(plain, null, 2);
    window._decrypted_plain = plain;
    setStatus('Decryption succeeded. Click "Load github_token into session" if token present.');
  }catch(e){
    setStatus('Decrypt failed: ' + (e && e.message ? e.message : e));
    id('plain').textContent = '{ decryption failed }';
  }
});

/* load token into sessionStorage */
id('loadToken').addEventListener('click', ()=>{
  try{
    const plain = window._decrypted_plain || JSON.parse(id('plain').textContent);
    if(!plain || !plain.secrets || !plain.secrets.github_token){
      setStatus('No secrets.github_token found in decrypted data.');
      return;
    }
    sessionStorage.setItem('gh.token', plain.secrets.github_token);
    setStatus('github_token loaded into sessionStorage (key: gh.token). Rogers enabled.');
    startChatMode();
  }catch(e){ setStatus('Load failed: ' + (e && e.message ? e.message : e)); }
});

/* copy plaintext */
id('copyPlain').addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(id('plain').textContent);
    setStatus('Plaintext copied to clipboard (be careful).');
  }catch(e){ setStatus('Copy failed: ' + (e && e.message ? e.message : e)); }
});

/* Chat rendering */
const CONSOLE = id('console');
function renderMessage(role, text){
  const el = document.createElement('div');
  el.className = role === 'user' ? 'msg-user' : 'msg-rogers';
  el.textContent = (role === 'user' ? 'You: ' : 'Rogers: ') + text;
  CONSOLE.appendChild(el);
  CONSOLE.scrollTop = CONSOLE.scrollHeight;
}

/* small helper: fetch raw or via API if token present in session */
async function fetchGithubFile(owner, repo, path, ref){
  const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(ref)}/${path}`;
  try{
    const r = await fetch(rawUrl, { cache:'no-store' });
    if(r.ok) return { ok:true, text: await r.text(), source: rawUrl };
  }catch(e){}
  // fallback to API using session token if present
  const token = sessionStorage.getItem('gh.token');
  if(token){
    const apiUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(ref)}`;
    const res = await fetch(apiUrl, { headers: { Authorization: 'Bearer ' + token, Accept: 'application/vnd.github.v3.raw' } });
    if(res.ok) return { ok:true, text: await res.text(), source: apiUrl };
    const body = await res.text().catch(()=>String(res.status));
    return { ok:false, err: `GitHub API ${res.status}: ${body}` };
  }
  return { ok:false, err: 'Not found (raw failed) and no token for API fallback.' };
}

/* a friendlier rogers logic (client-side). If you later add a helper server, this can forward to it. */
async function rogersRespond(q){
  // quick fetch pattern
  const fetchMatch = /^fetch\s+github\s+([^\s\/]+)\s+([^\s\/]+)\s+([^\s].*?)(?:\s+([^\s]+))?$/i.exec(q);
  if(fetchMatch){
    const owner = fetchMatch[1], repo = fetchMatch[2], path = fetchMatch[3], ref = fetchMatch[4] || 'main';
    renderMessage('rogers', `Trying to fetch ${path} from ${owner}/${repo}@${ref}...`);
    const f = await fetchGithubFile(owner, repo, path, ref);
    if(f.ok){
      const short = f.text.length > 2000 ? f.text.slice(0,2000) + "\n\n(Truncated)" : f.text;
      return `Fetched ${path} from ${owner}/${repo}@${ref} (source: ${f.source}):\n\n${short}`;
    } else {
      return `Fetch error: ${f.err}`;
    }
  }

  // help-ish queries
  if(/\bhelp\b|\bhow\b|\bwhat\b|\bwhy\b|\bdo you\b/i.test(q)){
    return "I can do simple repo fetches (try: fetch github owner repo path). I can also load a token from the encrypted blob and use it for private repo fetches. Tell me what you want me to fetch, or say 'save this' to get instructions to persist a line to logs.";
  }

  // save request
  if(/^\s*save\s*(.+)?/i.test(q)){
    const m = /^\s*save\s*(.+)?/i.exec(q);
    const content = m && m[1] ? m[1].trim() : null;
    if(!sessionStorage.getItem('gh.token')) return "I can save to the repo logs only if a token is loaded. Load your token first (decrypt and Load github_token).";
    if(!content) return "To save, type: save your text here";
    // do not auto-commit without owner/repo; ask user for confirm / info
    return "I can save that line into logs/conversation.txt, but I need the repo owner and name. Tell me 'save to owner repo' or use the file commit UI.";
  }

  // short casual replies & follow-ups
  if(/^hello\b/i.test(q)) return "Hello — I'm Rogers. Ask me to fetch files with 'fetch github owner repo path' or paste a passphrase to activate a saved token.";
  if(/^thanks?\b/i.test(q)) return "You're welcome. Anything else I can fetch or save?";
  if(q.length < 40) return "Got it. Do you want me to fetch a file from a repo (try 'fetch github owner repo path') or save this into the repo logs?";

  // last resort: echo and offer next steps
  return "I understood: \"" + q + "\". I can (A) fetch repos with 'fetch github owner repo path' (B) save to logs if a token is loaded. Which do you want?";
}

/* start chat mode after loading token / decrypt */
function startChatMode(){
  id('chatCard').style.display = 'block';
  id('console_status').textContent = 'Rogers active. Use the box below to talk or fetch files.';
  CONSOLE.textContent = ''; // clear console
  renderMessage('rogers','Rogers ready. Say hello or ask me to fetch a file (example: fetch github owner repo path).');
}

/* handle send */
id('send').addEventListener('click', async ()=>{
  const q = id('query').value.trim();
  if(!q) return;
  renderMessage('user', q);
  id('query').value = '';
  id('console_status').textContent = 'Rogers thinking...';
  try{
    // show a typing indicator
    renderMessage('rogers','(thinking...)');
    // compute response
    const resp = await rogersRespond(q);
    // remove last typing line
    const last = CONSOLE.lastChild;
    if(last && last.textContent && last.textContent.includes('(thinking...)')) CONSOLE.removeChild(last);
    renderMessage('rogers', resp);
    id('console_status').textContent = 'Done.';
  }catch(e){
    id('console_status').textContent = 'Error: ' + (e && e.message ? e.message : e);
    renderMessage('rogers','Error: ' + (e && e.message ? e.message : e));
  }
});

/* clear console */
id('clearConsole').addEventListener('click', ()=>{ CONSOLE.textContent = ''; });

/* Enter key to send */
id('query').addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); id('send').click(); } });

/* initialize (if token already in session, enable chat) */
(function init(){
  if(sessionStorage.getItem('gh.token')){
    setStatus('Token found in sessionStorage. Click Load github_token (again) or just start chat.');
    startChatMode();
  }
})();
</script>
</body>
</html>