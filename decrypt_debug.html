<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Decrypt Debug — PewPi</title>
<style>
  body{font-family:system-ui,Roboto,Arial;margin:14px;background:#071722;color:#e9fbff}
  .wrap{max-width:940px;margin:0 auto}
  .card{background:#08242f;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
  input,textarea,button,select{font:inherit}
  input,textarea,select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
  textarea{min-height:180px;resize:vertical;font-family:monospace}
  .row{display:flex;gap:8px;margin-top:8px}
  .col{flex:1}
  button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
  pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto;max-height:320px}
  .err{color:#ff9b9b}
  .muted{color:#9bb7c2}
</style>
</head>
<body>
  <div class="wrap">
    <h2>Decrypt Debug — PewPi</h2>

    <div class="card">
      <div class="muted">This page is verbose: it shows fetch/decrypt errors and token test results. Use it to paste the ciphertext JSON and your passphrase, or give raw URL to fetch the blob.</div>

      <label>Optional: raw URL to blob (raw.githubusercontent.com)</label>
      <input id="raw_url" placeholder="https://raw.githubusercontent.com/owner/repo/branch/secrets.json" />

      <div class="row">
        <button id="fetch_raw" class="secondary">Fetch raw URL</button>
        <button id="paste_clip" class="secondary">Paste from clipboard into blob</button>
        <button id="clear_blob" class="secondary">Clear blob</button>
      </div>

      <label style="margin-top:8px">Ciphertext JSON (paste exact JSON here if fetch fails)</label>
      <textarea id="blob_area" placeholder='Paste the ciphertext JSON object (the file content of secrets.json)'></textarea>

      <label style="margin-top:8px">Passphrase</label>
      <div class="row">
        <input id="pass" type="password" placeholder="Enter passphrase used when encrypting" class="col"/>
        <button id="decrypt_btn">Decrypt</button>
      </div>

      <div style="margin-top:8px" id="step_status" class="muted">Idle.</div>
      <div style="margin-top:8px">
        <strong>Errors / Diagnostic output</strong>
        <pre id="diag" class="err">{ no errors yet }</pre>
      </div>
    </div>

    <div class="card">
      <label>Decrypted output</label>
      <pre id="plain">{ nothing decrypted yet }</pre>
      <div class="row" style="margin-top:8px">
        <button id="load_token" class="secondary">Load github_token into sessionStorage (if present)</button>
        <button id="show_token" class="secondary">Show gh.token (sessionStorage)</button>
        <button id="clear_token" class="secondary">Clear gh.token</button>
      </div>
      <div style="margin-top:8px" id="token_status" class="muted">Session token not shown.</div>
    </div>

    <div class="card">
      <label>Token test (calls GET https://api.github.com/user)</label>
      <div class="row">
        <input id="test_token_input" placeholder="Paste token here to test quickly (optional)" />
        <button id="test_token_btn">Test token</button>
      </div>
      <div style="margin-top:8px">
        <strong>Token test result</strong>
        <pre id="token_test">{ none }</pre>
      </div>
    </div>

    <div class="card">
      <div class="muted">If decrypt fails: copy the text from the "Errors / Diagnostic output" box and paste it here so I can read the exact stack/message and tell you the fix.</div>
    </div>
  </div>

<script>
/* Debug helpers: WebCrypto AES-GCM + PBKDF2 parameters match your encrypted blob */
function id(n){ return document.getElementById(n); }
function diag(msg){ const d = id('diag'); d.textContent = (d.textContent === '{ no errors yet }' ? '' : d.textContent + '\\n') + msg; }
function setStep(s){ id('step_status').textContent = s; }

function b64ToU8(s){
  try{
    const bin = atob(s);
    const u = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i);
    return u;
  }catch(e){
    throw new Error('b64ToU8 failed: ' + e.message);
  }
}

async function deriveKey(pass, saltU8){
  try{
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
    return crypto.subtle.deriveKey({ name:'PBKDF2', salt: saltU8, iterations: 250000, hash: 'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, false, ['decrypt']);
  }catch(e){ throw new Error('deriveKey failed: ' + (e && e.message)); }
}

async function decryptBlob(blobJson, pass){
  if(!blobJson || !blobJson.ct) throw new Error('Blob missing "ct" field');
  const salt = b64ToU8(blobJson.salt);
  const iv   = b64ToU8(blobJson.iv);
  const ct   = b64ToU8(blobJson.ct);
  const key = await deriveKey(pass, salt);
  const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv: iv }, key, ct.buffer);
  const txt = new TextDecoder().decode(pt);
  try { return JSON.parse(txt); } catch(e){ throw new Error('Decrypted text is not valid JSON: ' + e.message + '\\nDecrypted text:\\n' + txt); }
}

/* UI wiring */
id('paste_clip').addEventListener('click', async ()=>{
  try{
    const text = await navigator.clipboard.readText();
    id('blob_area').value = text;
    setStep('Pasted clipboard into blob box.');
    diag('Clipboard pasted.');
  }catch(e){ diag('clipboard read failed: ' + e.message); setStep('Clipboard read failed'); }
});

id('clear_blob').addEventListener('click', ()=>{
  id('blob_area').value = '';
  id('plain').textContent = '{ nothing decrypted yet }';
  id('diag').textContent = '{ no errors yet }';
  setStep('Cleared.');
});

id('fetch_raw').addEventListener('click', async ()=>{
  const raw = id('raw_url').value.trim();
  if(!raw){ alert('Enter the raw.githubusercontent.com URL to fetch'); return; }
  setStep('Fetching raw URL: ' + raw);
  try{
    const r = await fetch(raw, { cache:'no-store' });
    if(!r.ok){ const t = await r.text().catch(()=>r.status); diag('Fetch returned: ' + r.status + ' - ' + t); setStep('Fetch failed: ' + r.status); return; }
    const txt = await r.text();
    id('blob_area').value = txt;
    setStep('Fetched raw blob and pasted into textarea.');
    diag('Fetch OK: raw blob loaded.');
  }catch(e){ diag('Fetch error: ' + e.message); setStep('Fetch error'); }
});

id('decrypt_btn').addEventListener('click', async ()=>{
  id('plain').textContent = '{ decrypting... }';
  id('diag').textContent = '{ no errors yet }';
  setStep('Parsing JSON from blob textarea...');
  const txt = id('blob_area').value.trim();
  const pass = id('pass').value;
  if(!txt){ diag('No blob text found.'); setStep('Abort: no blob'); return; }
  if(!pass){ diag('Passphrase field empty.'); setStep('Abort: no passphrase'); return; }

  let blob = null;
  try{
    blob = JSON.parse(txt);
  }catch(e){
    diag('JSON.parse failed: ' + e.message);
    // try to extract first JSON object substring
    const m = txt.match(/\\{[\\s\\S]*\\}/);
    if(m){ try{ blob = JSON.parse(m[0]); diag('Extracted JSON substring.'); } catch(err){ diag('Extracted substring parse also failed: ' + err.message); } }
  }
  if(!blob){ setStep('Could not parse blob JSON.'); id('plain').textContent = '{ invalid blob JSON }'; return; }

  setStep('Attempting decryption (in browser).');
  try{
    const plain = await decryptBlob(blob, pass);
    id('plain').textContent = JSON.stringify(plain, null, 2);
    setStep('Decryption succeeded.');
    diag('Decryption OK.');
    // also show if token present
    if(plain && plain.secrets && plain.secrets.github_token){
      diag('Found secrets.github_token in plaintext (not loaded yet).');
    } else {
      diag('No secrets.github_token found in plaintext.');
    }
  }catch(e){
    diag('Decrypt error: ' + (e && e.message ? e.message : e));
    setStep('Decrypt failed — see diagnostics.');
    id('plain').textContent = '{ decryption failed }';
  }
});

/* sessionStorage token controls */
id('load_token').addEventListener('click', ()=>{
  try{
    const plainText = id('plain').textContent;
    if(!plainText || plainText.startsWith('{') && plainText.includes('nothing')){ alert('No plaintext available; decrypt first'); return; }
    const obj = JSON.parse(plainText);
    if(!obj.secrets || !obj.secrets.github_token){ alert('No secrets.github_token present in plaintext'); return; }
    sessionStorage.setItem('gh.token', obj.secrets.github_token);
    id('token_status').textContent = 'gh.token stored in sessionStorage';
    diag('gh.token stored in sessionStorage (in-memory only).');
  }catch(e){ diag('load_token error: ' + e.message); id('token_status').textContent = 'Load failed'; }
});

id('show_token').addEventListener('click', ()=>{
  try{
    const t = sessionStorage.getItem('gh.token');
    id('token_status').textContent = t ? 'gh.token present (length ' + t.length + ')' : 'no gh.token in sessionStorage';
    diag('Show token status: ' + (t ? 'present length ' + t.length : 'absent'));
  }catch(e){ diag('show_token error: ' + e.message); }
});

id('clear_token').addEventListener('click', ()=>{
  sessionStorage.removeItem('gh.token');
  id('token_status').textContent = 'gh.token removed';
  diag('gh.token cleared from sessionStorage.');
});

/* test token: GET /user */
id('test_token_btn').addEventListener('click', async ()=>{
  const tinput = id('test_token_input').value.trim();
  const token = tinput || sessionStorage.getItem('gh.token');
  if(!token){ alert('No token provided or stored'); return; }
  id('token_test').textContent = '{ testing... }';
  try{
    const r = await fetch('https://api.github.com/user', { headers: { Authorization: 'Bearer ' + token, Accept:'application/vnd.github.v3+json' } });
    const j = await r.json().catch(()=>null);
    id('token_test').textContent = JSON.stringify({ status: r.status, body: j }, null, 2);
    diag('Token test result: ' + r.status + (j && j.message ? ' message: ' + j.message : ''));
  }catch(e){ id('token_test').textContent = 'Test error: ' + e.message; diag('Token test error: ' + e.message); }
});
</script>
</body>
</html>