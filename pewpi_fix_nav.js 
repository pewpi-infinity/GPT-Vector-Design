// pewpi_fix_nav.js
// Hardens the hamburger nav so buttons reliably switch views on touch and desktop.
// Paste this before </body> or save as pewpi_fix_nav.js and include it.

(function(){
  function dbg(msg){
    try{
      const out = document.getElementById('pewpi_debug_out');
      const ts = new Date().toISOString().split('T')[1].slice(0,8);
      if(out) out.textContent = (out.textContent && out.textContent !== '{ no errors }' ? out.textContent + '\n' : '') + `[${ts}] ${msg}`;
      console.log('[pewpi_fix_nav] ' + msg);
    }catch(e){ console.log('[pewpi_fix_nav] dbg error', e); }
  }

  function showView(name){
    // Hide everything with class "view", then show the requested
    const views = Array.from(document.querySelectorAll('.view'));
    views.forEach(v => {
      try { v.style.display = 'none'; v.classList.remove('pewpi-active-view'); } catch(_) {}
    });
    const el = document.getElementById('view_' + name);
    if(!el){ dbg('showView: view not found: ' + name); return false; }
    try{
      el.style.display = 'block';
      el.classList.add('pewpi-active-view');
      // scroll to top of that column to ensure visible
      el.scrollIntoView({behavior:'smooth', block:'start'});
      dbg('showView: shown ' + name);
      // small visual flash to confirm
      el.style.transition = 'background-color 260ms';
      const old = el.style.backgroundColor;
      el.style.backgroundColor = 'rgba(22,176,122,0.06)';
      setTimeout(()=>{ el.style.backgroundColor = old; }, 300);
      return true;
    }catch(e){ dbg('showView error: ' + e.message); return false; }
  }

  function setActiveButton(btn){
    Array.from(document.querySelectorAll('.btn')).forEach(b => b.classList.remove('active'));
    if(btn) btn.classList.add('active');
  }

  function attachNav(){
    const buttons = Array.from(document.querySelectorAll('.btn[data-view]'));
    if(buttons.length === 0){ dbg('attachNav: no nav buttons found'); return; }
    buttons.forEach(btn => {
      if(btn.__pewpi_nav_attached) return;
      const handler = function(ev){
        try{
          // ensure taps trigger like clicks
          if(ev && (ev.type === 'touchstart' || ev.type === 'touchend')) ev.preventDefault();
          const view = btn.getAttribute('data-view') || btn.dataset.view;
          setActiveButton(btn);
          const ok = showView(view);
          if(!ok) dbg('attachNav: failed to show view ' + view);
        }catch(e){ dbg('nav handler error: ' + (e && e.message ? e.message : e)); }
      };
      // prefer click, but add touchstart for mobile responsiveness
      btn.addEventListener('click', handler, false);
      btn.addEventListener('touchstart', handler, {passive:false});
      btn.__pewpi_nav_attached = true;
      // make sure the button is not blocked
      try{ btn.disabled = false; btn.style.pointerEvents = 'auto'; btn.style.touchAction = 'manipulation'; }catch(e){}
      dbg('attachNav: handlers attached for ' + (btn.id || btn.textContent.trim()));
    });
  }

  // If something is sitting on top of the UI, detect and outline it (user can visually confirm)
  function highlightPotentialOverlays(){
    const candidates = Array.from(document.querySelectorAll('body *')).filter(el=>{
      try{
        const s = getComputedStyle(el);
        if(s.display === 'none' || s.visibility === 'hidden' || el === document.getElementById('pewpi_debug_panel')) return false;
        const pos = s.position;
        const z = parseInt(s.zIndex || 0, 10);
        return (pos === 'fixed' || pos === 'absolute') && z > 50;
      }catch(e){ return false; }
    });
    if(candidates.length === 0){ dbg('highlightPotentialOverlays: none found'); return; }
    candidates.forEach(el=>{
      el.dataset.__pewpi_oldOutline = el.style.outline || '';
      el.style.outline = '2px dashed rgba(255,165,0,0.9)';
    });
    dbg('highlightPotentialOverlays: outlined ' + candidates.length + ' elements (they may block clicks).');
    // auto-remove outlines after 6s
    setTimeout(()=>{ candidates.forEach(el => { if(el.dataset && el.dataset.__pewpi_oldOutline !== undefined){ el.style.outline = el.dataset.__pewpi_oldOutline || ''; delete el.dataset.__pewpi_oldOutline; } }); dbg('highlightPotentialOverlays: cleared outlines'); }, 6000);
  }

  function runFix(){
    try{
      attachNav();
      highlightPotentialOverlays();
      // ensure at least portal view visible
      const anyVisible = Array.from(document.querySelectorAll('.view')).some(v => v.style.display !== 'none');
      if(!anyVisible) showView('portal');
      dbg('runFix: executed');
    }catch(e){ dbg('runFix error: ' + e.message); }
  }

  // run on DOM ready
  function ready(fn){
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
  }

  ready(function(){
    // initial attach and a couple of retries (handles race with other scripts)
    runFix();
    setTimeout(runFix, 600);
    setTimeout(runFix, 1600);
    // expose for debug panel
    window.__pewpi_nav_fix = { runFix, attachNav, showView, dbg };
    dbg('pewpi_fix_nav initialized');
  });
})();