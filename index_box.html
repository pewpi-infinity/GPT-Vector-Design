<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PewPi — Bot Manager (safe, browser-only)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071722;color:#e9fbff}
  .wrap{max-width:1000px;margin:0 auto}
  .card{background:#08242f;padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
  input,textarea,select,button{font:inherit}
  input,select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
  textarea{min-height:120px;resize:vertical;font-family:monospace}
  .row{display:flex;gap:8px;margin-top:8px}
  .col{flex:1}
  button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
  pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto;max-height:260px}
  .muted{color:#9bb7c2;font-size:0.9rem}
  .status{margin-top:8px;color:#cfeee6}
  .bot{padding:8px;border-radius:8px;background:#0a3740;margin-top:8px}
  .danger{color:#ff9b9b}
</style>
</head>
<body>
  <div class="wrap">
    <h1>PewPi — Bot Manager (browser-only, safe)</h1>

    <div class="card">
      <div class="muted"><strong>Security:</strong> Do NOT commit passphrases or raw tokens. Use a dedicated PAT for commits and revoke it after use. Bots run only in your browser. No automatic propagation or hidden replication is performed.</div>
    </div>

    <div class="card">
      <label>Session token (PAT) — load to allow commits or private repo fetches</label>
      <div class="row">
        <input id="pat" type="password" placeholder="Paste PAT here (memory only)" />
        <button id="load_pat" class="secondary">Load</button>
        <button id="clear_pat" class="secondary">Clear</button>
      </div>
      <div id="pat_status" class="status">No PAT loaded.</div>
    </div>

    <div class="card">
      <label>Create new bot</label>
      <div class="row">
        <input id="bot_name" placeholder="Bot name (eg. fetcher-1)" class="col"/>
        <select id="bot_type">
          <option value="echo">Echo (simple)</option>
          <option value="fetch_github">Fetch GitHub file</option>
          <option value="transform">Transform text (upper/lower)</option>
        </select>
        <button id="create_bot">Create Bot</button>
      </div>

      <div class="muted" style="margin-top:8px">Bots are JS objects that run tasks on demand. No background network scanning. You approve any child bot creation.</div>
    </div>

    <div class="card">
      <label>Active bots</label>
      <div id="bots_list"></div>
    </div>

    <div class="card">
      <label>Activity log (in-memory)</label>
      <pre id="activity_log">{ no activity }</pre>
      <div class="row">
        <button id="download_log">Download log (plaintext)</button>
        <button id="encrypt_and_copy" class="secondary">Encrypt log to clipboard</button>
        <button id="encrypt_and_commit" class="secondary">Encrypt & Commit to repo (needs PAT)</button>
      </div>

      <div style="margin-top:8px" class="row">
        <input id="commit_owner" placeholder="owner (username/org)" class="col" value="pewpi-infinity"/>
        <input id="commit_repo" placeholder="repo name" class="col" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="commit_branch" placeholder="branch" value="main" />
        <input id="commit_path" placeholder="file path (eg. pewpi_bot_logs.json)" value="pewpi_bot_logs.json" />
      </div>
      <div id="commit_status" class="status"></div>
    </div>

    <div class="card">
      <label>Decrypt helpers (use to validate)</label>
      <div class="row">
        <input id="dec_pass" type="password" placeholder="Passphrase to encrypt/decrypt" class="col"/>
        <button id="test_decrypt" class="secondary">Test decrypt last encrypted</button>
      </div>
      <div id="dec_status" class="status"></div>
    </div>

    <div class="card danger">
      <div class="muted">Danger area: the UI supports manual spawn-of-child requests, but you must click to confirm. The system will never auto-create bots on other machines or repos. Use responsibly.</div>
    </div>
  </div>

<script>
/* Simple BotManager (client-only). No automatic propagation. Logs and encryption use WebCrypto PBKDF2+AES-GCM
   Parameters: PBKDF2 iterations 250000, hash SHA-256, AES-GCM 256.
*/

const state = {
  TOKEN: null,           // in-memory PAT
  bots: {},              // {id: Bot}
  log: [],               // activity log entries
  lastEncrypted: null    // store ciphertext JSON of last encrypted log (not auto-sent)
};

/* ---------- utility helpers ---------- */
function id(n){ return document.getElementById(n); }
function now(){ return new Date().toISOString(); }
function appendLog(entry){
  state.log.push({ ts: now(), entry });
  id('activity_log').textContent = JSON.stringify(state.log, null, 2);
}

/* ---------- PAT UI ---------- */
id('load_pat').addEventListener('click', ()=>{
  const t = id('pat').value.trim();
  if(!t) return alert('Paste PAT first');
  state.TOKEN = t;
  id('pat_status').textContent = 'PAT loaded in memory (not persisted).';
});
id('clear_pat').addEventListener('click', ()=>{
  state.TOKEN = null; id('pat').value=''; id('pat_status').textContent = 'PAT cleared.';
});

/* ---------- Bot implementation ---------- */
let botCounter = 0;
class Bot {
  constructor(name, type){
    this.id = ++botCounter;
    this.name = name || ('bot-' + this.id);
    this.type = type || 'echo';
    this.created_at = now();
    this.enabled = true;
    this.childrenRequested = 0;
    appendLog(`Bot created: ${this.name} (${this.type})`);
  }

  // run a task with optional payload; returns result or throws
  async run(payload){
    appendLog(`Bot ${this.name} run called with payload: ${JSON.stringify(payload)}`);
    if(this.type === 'echo'){
      const out = payload && payload.text ? payload.text : '(echo)';
      appendLog(`Bot ${this.name} echo -> ${out}`);
      return out;
    }
    if(this.type === 'transform'){
      const mode = payload && payload.mode ? payload.mode : 'upper';
      const text = payload && payload.text ? payload.text : '';
      const out = mode === 'lower' ? text.toLowerCase() : text.toUpperCase();
      appendLog(`Bot ${this.name} transform(${mode}) -> ${out}`);
      return out;
    }
    if(this.type === 'fetch_github'){
      // payload: { owner, repo, path, ref }
      const owner = payload && payload.owner ? payload.owner : id('commit_owner').value.trim();
      const repo = payload && payload.repo ? payload.repo : id('commit_repo').value.trim();
      const path = payload && payload.path ? payload.path : '';
      const ref  = payload && payload.ref ? payload.ref : (id('commit_branch').value.trim() || 'main');
      if(!owner || !repo || !path) {
        const m = 'fetch_github requires owner, repo, and path';
        appendLog(`Bot ${this.name} fetch error: ${m}`);
        throw new Error(m);
      }
      appendLog(`Bot ${this.name} fetching ${owner}/${repo}@${ref}/${path}`);
      // try raw first
      const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(ref)}/${path}`;
      try{
        const res = await fetch(rawUrl, { cache:'no-store' });
        if(res.ok){ const text = await res.text(); appendLog(`Bot ${this.name} fetched raw (${rawUrl})`); return text; }
      }catch(e){ /* ignore */ }
      // fallback API if token
      if(state.TOKEN){
        const api = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(ref)}`;
        const res = await fetch(api, { headers: { Authorization: 'Bearer ' + state.TOKEN, Accept: 'application/vnd.github.v3.raw' }});
        if(res.ok){ const text = await res.text(); appendLog(`Bot ${this.name} fetched API (${api})`); return text; }
        const body = await res.text().catch(()=>String(res.status));
        const msg = `GitHub API ${res.status}: ${body}`;
        appendLog(`Bot ${this.name} API error: ${msg}`);
        throw new Error(msg);
      } else {
        const msg = 'Not found (raw failed) and no token for API.';
        appendLog(`Bot ${this.name} fetch error: ${msg}`);
        throw new Error(msg);
      }
    }
    throw new Error('Unknown bot type: ' + this.type);
  }

  // request spawn child (user must approve)
  requestSpawnChild(childName, childType){
    this.childrenRequested++;
    appendLog(`Bot ${this.name} requested spawn of child ${childName} (${childType})`);
    // UI prompt to user
    const ok = confirm(`Bot "${this.name}" requests to spawn a child bot "${childName}" of type "${childType}". Approve?`);
    if(ok){
      const b = createBot(childName, childType);
      appendLog(`Child bot ${b.name} created (approved).`);
      return b;
    } else {
      appendLog(`User denied spawn request from ${this.name}.`);
      return null;
    }
  }
}

/* ---------- UI: create/list bots ---------- */
function renderBots(){
  const list = id('bots_list'); list.innerHTML = '';
  for(const k of Object.keys(state.bots)){
    const b = state.bots[k];
    const div = document.createElement('div'); div.className = 'bot';
    div.innerHTML = `<div><strong>${b.name}</strong> (${b.type}) — created ${b.created_at}</div>`;
    const runBtn = document.createElement('button'); runBtn.textContent = 'Run';
    runBtn.addEventListener('click', async ()=>{
      try{
        const payloadText = prompt('Enter payload JSON for the bot (or empty):', '{"text":"hello"}');
        const payload = payloadText ? JSON.parse(payloadText) : {};
        const res = await b.run(payload);
        alert('Bot result:\\n' + (typeof res === 'string' ? res : JSON.stringify(res)));
      }catch(e){ alert('Bot run error: ' + e.message); appendLog(`Bot ${b.name} run error: ${e.message}`); }
      renderBots();
    });
    const spawnBtn = document.createElement('button'); spawnBtn.textContent = 'Request child';
    spawnBtn.addEventListener('click', ()=>{
      const childName = prompt('Child bot name:', b.name + '-child');
      const childType = prompt('Child type (echo/transform/fetch_github):', 'echo');
      b.requestSpawnChild(childName, childType);
      renderBots();
    });
    const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', ()=>{
      if(confirm('Remove bot ' + b.name + '?')){ delete state.bots[b.id]; appendLog(`Bot removed: ${b.name}`); renderBots(); }
    });
    div.appendChild(runBtn); div.appendChild(spawnBtn); div.appendChild(removeBtn);
    list.appendChild(div);
  }
}

function createBot(name, type){
  const b = new Bot(name, type);
  state.bots[b.id] = b;
  renderBots();
  return b;
}

id('create_bot').addEventListener('click', ()=>{
  const name = id('bot_name').value.trim() || null;
  const type = id('bot_type').value;
  createBot(name, type);
  id('bot_name').value='';
});

/* ---------- Log download / encrypt / commit ---------- */
/* Encryption helpers (same scheme as your other pages) */
const ITER = 250000, SALT_BYTES = 16, IV_BYTES = 12;
function randU8(n){ const u=new Uint8Array(n); crypto.getRandomValues(u); return u; }
function u8ToB64(u8){
  let s=''; for(let i=0;i<u8.length;i++) s+=String.fromCharCode(u8[i]); return btoa(s);
}
function b64ToU8Arr(s){ const bin=atob(s); const u = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i); return u; }

async function deriveKey(pass, salt){
  const km = await crypto.subtle.importKey('raw', new TextEncoder().encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations:ITER, hash:'SHA-256' }, km, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
}

async function encryptJSON(obj, pass){
  const salt = randU8(SALT_BYTES);
  const iv = randU8(IV_BYTES);
  const key = await deriveKey(pass, salt);
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, new TextEncoder().encode(JSON.stringify(obj)));
  return { v:1, salt: u8ToB64(salt), iv: u8ToB64(iv), ct: u8ToB64(new Uint8Array(ct)), created_at: new Date().toISOString() };
}

async function decryptJSON(blob, pass){
  const salt = b64ToU8Arr(blob.salt);
  const iv = b64ToU8Arr(blob.iv);
  const ct = b64ToU8Arr(blob.ct);
  const key = await deriveKey(pass, salt);
  const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ct.buffer);
  return JSON.parse(new TextDecoder().decode(pt));
}

id('download_log').addEventListener('click', ()=>{
  const data = JSON.stringify(state.log, null, 2);
  const blob = new Blob([data], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='pewpi_bot_log.json'; a.click(); URL.revokeObjectURL(url);
});

id('encrypt_and_copy').addEventListener('click', async ()=>{
  const pass = id('dec_pass').value;
  if(!pass) return alert('Enter passphrase in Decrypt helpers box');
  const ct = await encryptJSON({ log: state.log }, pass);
  state.lastEncrypted = ct;
  await navigator.clipboard.writeText(JSON.stringify(ct, null, 2));
  id('dec_status').textContent = 'Encrypted log copied to clipboard.';
});

id('test_decrypt').addEventListener('click', async ()=>{
  const pass = id('dec_pass').value;
  if(!pass) return alert('Enter passphrase');
  if(!state.lastEncrypted) return alert('No last encrypted blob in memory. Use Encrypt & Copy first.');
  try{
    const plain = await decryptJSON(state.lastEncrypted, pass);
    id('dec_status').textContent = 'Decrypt OK: ' + (plain.log ? plain.log.length + ' entries' : 'no log');
  }catch(e){ id('dec_status').textContent = 'Decrypt failed: ' + e.message; }
});

/* Commit encrypted blob to repo (requires TOKEN) */
async function getFileInfo(owner, repo, path, branch){
  const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  const r = await fetch(url, { headers: state.TOKEN ? { Authorization: 'Bearer ' + state.TOKEN, Accept:'application/vnd.github.v3+json' } : { Accept:'application/vnd.github.v3+json' } });
  if(r.status === 404) return { exists:false };
  const j = await r.json();
  if(!r.ok) throw new Error('GET failed: ' + (j && j.message ? j.message : r.status));
  return { exists:true, sha: j.sha, content: j.content };
}

async function commitFile(owner, repo, branch, path, message, contentBase64, sha){
  const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}`;
  const body = { message, content: contentBase64, branch };
  if(sha) body.sha = sha;
  const r = await fetch(url, {
    method:'PUT',
    headers:{ Authorization: 'Bearer ' + state.TOKEN, Accept:'application/vnd.github.v3+json', 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  const j = await r.json().catch(()=>null);
  if(!r.ok) throw new Error('Commit failed: ' + (j && j.message ? j.message : JSON.stringify(j)));
  return j;
}

id('encrypt_and_commit').addEventListener('click', async ()=>{
  try{
    if(!state.TOKEN) return alert('Load a PAT first to commit');
    const pass = id('dec_pass').value;
    if(!pass) return alert('Enter passphrase to encrypt the log');
    const owner = id('commit_owner').value.trim(), repo = id('commit_repo').value.trim();
    const branch = id('commit_branch').value.trim() || 'main', path = id('commit_path').value.trim() || 'pewpi_bot_logs.json';
    if(!owner || !repo) return alert('owner and repo required');
    id('commit_status').textContent = 'Encrypting...';
    const ct = await encryptJSON({ log: state.log }, pass);
    state.lastEncrypted = ct;
    id('commit_status').textContent = 'Checking existing file...';
    let info = await getFileInfo(owner, repo, path, branch).catch(e => { if(e.message && e.message.includes('404')) return { exists:false }; else throw e; });
    id('commit_status').textContent = 'Committing encrypted log...';
    const base64 = btoa(JSON.stringify(ct, null, 2));
    const res = await commitFile(owner, repo, branch, path, 'Add encrypted bot log', base64, info.exists ? info.sha : undefined);
    id('commit_status').textContent = 'Commit OK: ' + (res && res.commit && res.commit.sha ? res.commit.sha : 'ok');
    appendLog(`Encrypted log committed to ${owner}/${repo}@${branch}/${path}`);
  }catch(e){ id('commit_status').textContent = 'Error: ' + e.message; appendLog('Commit error: ' + e.message); }
});

/* initialize UI */
(function init(){
  id('activity_log').textContent = JSON.stringify(state.log, null, 2);
  id('bots_list').textContent = '(no bots)';
})();
</script>
</body>
</html>