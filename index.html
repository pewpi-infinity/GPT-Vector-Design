<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PewPi — Quick Activate Rogers</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071722;color:#e9fbff}
    .wrap{max-width:900px;margin:0 auto}
    h1{margin:0 0 10px 0}
    .card{background:#08242f;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
    input,textarea,button{font:inherit}
    input,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
    textarea{min-height:120px;resize:vertical;font-family:monospace}
    .row{display:flex;gap:8px;margin-top:8px}
    .col{flex:1}
    button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
    .secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
    pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto;max-height:320px}
    .muted{color:#9bb7c2;font-size:0.9rem}
    .status{margin-top:8px;color:#cfeee6}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PewPi — Quick Activate Rogers</h1>

    <div class="card">
      <div class="muted">Paste the passphrase you used to create the encrypted blob (secrets.json). Click Activate — Rogers will automatically find your blob, decrypt it, load the token into session, and enable chat below.</div>

      <div class="row" style="margin-top:8px">
        <input id="passphrase" type="password" placeholder="Enter passphrase (only in your browser)" />
        <button id="activate">Activate Rogers</button>
      </div>

      <div class="status" id="activate_status">Idle. Click Activate when ready.</div>
    </div>

    <div class="card" id="rogers_card" style="display:none">
      <label style="font-weight:700">Rogers (chat)</label>
      <div id="console" style="border:1px solid rgba(255,255,255,0.03);padding:10px;border-radius:8px;background:#041016;min-height:180px;white-space:pre-wrap;overflow:auto"></div>
      <div class="row" style="margin-top:8px">
        <input id="query" placeholder='Type "fetch github owner repo path [ref]" or say hello' />
        <button id="send">Send</button>
      </div>
      <div class="status" id="console_status">Rogers inactive until activation.</div>
    </div>
  </div>

<script>
/*
  Minimal page that:
  - auto-tries to find an encrypted blob (secrets.json / pewpi_secrets.json) across candidate repo names & branches
  - decrypts blob with passphrase (PBKDF2 250k + AES-GCM) in-browser
  - if secrets.github_token found, loads into sessionStorage and enables a simple client-side "Rogers"
  - Rogers supports basic "fetch github owner repo path [ref]" (uses token for private repos if present)
*/

/* ---------- Configuration: candidate repo names & paths ---------- */
/* If you know your repo name, you can add it here for faster fetch. */
const OWNER = "pewpi-infinity";
const CANDIDATE_REPOS = [
  "pewpi-infinity",       // often repo same as user/org
  "GPT-Vectors-Design",
  "Vector",
  "Vector-Design",
  "infinity-portal",
  "InfinityOS",
  "pewpi-infinity.github.io"
];
const CANDIDATE_PATHS = ["secrets.json","pewpi_secrets.json","pewpi_secrets.json.enc"];
const CANDIDATE_BRANCHES = ["main","master"];

/* ---------- helpers ---------- */
function id(n){ return document.getElementById(n); }
function log(s){ const c=id('console'); c.textContent += (c.textContent?'\n':'') + s; c.scrollTop = c.scrollHeight; }
function setStatus(s){ id('activate_status').textContent = s; }
function setConsoleStatus(s){ id('console_status').textContent = s; }

/* base64 -> Uint8Array */
function b64ToU8(s){
  const bin = atob(s);
  const u = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i);
  return u;
}

/* derive key */
async function deriveKey(pass, saltU8){
  const enc = new TextEncoder();
  const km = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({ name:'PBKDF2', salt: saltU8, iterations: 250000, hash:'SHA-256'}, km, { name:'AES-GCM', length:256 }, false, ['decrypt']);
}

/* decrypt blob produced by the account manager */
async function decryptBlob(blob, pass){
  if(!blob || !blob.ct) throw new Error('blob missing ct');
  const salt = b64ToU8(blob.salt);
  const iv   = b64ToU8(blob.iv);
  const ct   = b64ToU8(blob.ct);
  const key = await deriveKey(pass, salt);
  const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ct.buffer);
  const txt = new TextDecoder().decode(pt);
  return JSON.parse(txt);
}

/* attempt to fetch raw blob from raw.githubusercontent for given owner/repo/branch/path */
async function tryFetchRaw(owner, repo, branch, path){
  const url = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(branch)}/${path}`;
  try {
    const r = await fetch(url, { cache:'no-store' });
    if(r.ok) return await r.text();
  } catch(e){ /* ignore */ }
  return null;
}

/* attempt to find the blob by trying many repo/path/branch combos */
async function autodiscoverBlob(pass){
  setStatus('Searching for encrypted blob...');
  for(const repo of CANDIDATE_REPOS){
    for(const branch of CANDIDATE_BRANCHES){
      for(const path of CANDIDATE_PATHS){
        setStatus(`Trying ${repo}@${branch}/${path} ...`);
        const raw = await tryFetchRaw(OWNER, repo, branch, path);
        if(raw){
          setStatus(`Found blob at ${OWNER}/${repo}@${branch}/${path}`);
          return { raw, repo, branch, path };
        }
      }
    }
  }
  setStatus('Auto-discover failed (no raw file found). If your repo is private, you must paste the blob JSON manually via the console or load a PAT and re-run.');
  return null;
}

/* If repo is private: try to fetch using GitHub API with token */
async function fetchBlobWithToken(owner, repo, branch, path, token){
  const api = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  const res = await fetch(api, { headers: { Authorization: 'Bearer ' + token, Accept: 'application/vnd.github.v3.raw' } });
  if(res.ok) return await res.text();
  const txt = await res.text().catch(()=>String(res.status));
  throw new Error('API fetch failed: ' + res.status + ' ' + txt);
}

/* ---------- Activation flow ---------- */
async function activateRogers(){
  const pass = id('passphrase').value;
  if(!pass){ alert('Enter passphrase'); return; }
  setStatus('Starting activation...');
  // 1) try auto-discover raw public blobs
  let found = await autodiscoverBlob(pass);
  let rawText = null;
  let discoveredInfo = null;

  if(found) {
    rawText = found.raw;
    discoveredInfo = found;
  } else {
    // 2) attempt to use a token if the user previously decrypted and stored one in sessionStorage
    const storedToken = sessionStorage.getItem('gh.token');
    if(storedToken){
      setStatus('Trying API fetch with token (private repo) ...');
      for(const repo of CANDIDATE_REPOS){
        for(const branch of CANDIDATE_BRANCHES){
          for(const path of CANDIDATE_PATHS){
            try{
              const t = await fetchBlobWithToken(OWNER, repo, branch, path, storedToken);
              rawText = t; discoveredInfo = { repo, branch, path }; break;
            }catch(e){ /* continue */ }
          }
          if(rawText) break;
        }
        if(rawText) break;
      }
    }
  }

  if(!rawText){
    // no automatic fetch; ask user to paste the ciphertext JSON directly (simple and fast)
    const pasted = prompt('Auto-discover failed. Paste the ciphertext JSON (the encrypted blob) now (cancel to abort):');
    if(!pasted){ setStatus('Activation aborted by user.'); return; }
    rawText = pasted;
  }

  // parse JSON and decrypt
  let blob;
  try {
    blob = (typeof rawText === 'string') ? JSON.parse(rawText) : rawText;
  } catch(e){
    // try to extract JSON substring if the raw contains wrappers
    try{
      const m = rawText.match(/\{[\s\S]*\}/);
      blob = m ? JSON.parse(m[0]) : null;
    } catch(err){ blob = null; }
  }
  if(!blob){ setStatus('Could not parse blob JSON. Activation failed.'); alert('Blob JSON parse failed.'); return; }

  setStatus('Decrypting in browser...');
  let plain;
  try {
    plain = await decryptBlob(blob, pass);
  } catch(e){
    setStatus('Decrypt failed: wrong passphrase?');
    alert('Decrypt failed: ' + (e && e.message ? e.message : e));
    return;
  }

  // store plaintext in memory and token in session
  window._rogers_plain = plain;
  if(plain && plain.secrets && plain.secrets.github_token){
    sessionStorage.setItem('gh.token', plain.secrets.github_token);
    setStatus('Decryption OK — token loaded into sessionStorage (gh.token). Rogers ready.');
  } else {
    setStatus('Decryption OK — no github_token found in blob. Rogers ready (public-only).');
  }

  // show and enable Rogers UI
  id('rogers_card').style.display = 'block';
  id('activate').disabled = true;
  id('passphrase').disabled = true;
  setConsoleStatus('Rogers active. Type commands in the box and press Send.');
  log('Rogers activated. Decrypted account: ' + (plain.meta && plain.meta.created_by ? plain.meta.created_by : '(unknown)'));
}

/* ---------- small client-side rogers logic ---------- */
async function fetchGithubFileClient(owner, repo, path, ref){
  // try raw first (public)
  const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(ref)}/${path}`;
  try{
    const r = await fetch(rawUrl, { cache:'no-store' });
    if(r.ok) return { ok:true, text: await r.text(), source: rawUrl };
  }catch(e){ /* ignore */ }

  // fallback to API with token if present
  const token = sessionStorage.getItem('gh.token') || null;
  if(token){
    const api = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(ref)}`;
    const r = await fetch(api, { headers: { Authorization: 'Bearer ' + token, Accept: 'application/vnd.github.v3.raw' } });
    if(r.ok) return { ok:true, text: await r.text(), source: api };
    const txt = await r.text().catch(()=>String(r.status));
    return { ok:false, err:`GitHub API ${r.status}: ${txt}` };
  }

  return { ok:false, err:'Not found (raw failed) and no token available for API.' };
}

async function rogersHandle(query){
  query = (query||'').trim();
  if(!query) return 'Empty query';
  const fetchMatch = /^fetch\\s+github\\s+([^\\s\\/]+)\\s+([^\\s\\/]+)\\s+([^\\s].*?)(?:\\s+([^\\s]+))?$/i.exec(query);
  if(fetchMatch){
    const owner = fetchMatch[1], repo = fetchMatch[2], path = fetchMatch[3], ref = fetchMatch[4] || 'main';
    const res = await fetchGithubFileClient(owner, repo, path, ref);
    if(res.ok){
      if(res.text.length > 2500) return `Fetched ${path} from ${owner}/${repo}@${ref} (truncated):\\n\\n${res.text.slice(0,2500)}\\n\\n(Use raw URL for full)`;
      return `Fetched ${path} from ${owner}/${repo}@${ref}:\\n\\n${res.text}`;
    } else return 'Fetch error: ' + res.err;
  }
  if(/^hello$/i.test(query)) return 'Hello — Rogers (client) here.';
  return 'Rogers (client) received: ' + query;
}

/* ---------- chat wiring ---------- */
id('activate').addEventListener('click', activateRogers);

id('send').addEventListener('click', async ()=>{
  const q = id('query').value.trim();
  if(!q) return;
  log('You: ' + q);
  setConsoleStatus('Thinking...');
  try{
    const r = await rogersHandle(q);
    log('Rogers: ' + r);
    setConsoleStatus('Done.');
  }catch(e){
    log('Rogers error: ' + (e && e.message ? e.message : e));
    setConsoleStatus('Error');
  }
  id('query').value = '';
});

/* allow Enter to send */
id('query').addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){ e.preventDefault(); id('send').click(); }
});

/* initialize UI state */
(function init(){
  id('rogers_card').style.display = 'none';
  if(sessionStorage.getItem('gh.token')){
    setStatus('Token already in sessionStorage. Click Activate to attempt private fetch.');
  }
})();
</script>
</body>
</html>