<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PewPi — Commit to GitHub from Browser</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071722;color:#e9fbff}
    .wrap{max-width:980px;margin:0 auto}
    h1{margin:0 0 10px 0}
    .card{background:#08242f;padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
    input,textarea,select,button{font:inherit}
    input,select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
    textarea{min-height:220px;resize:vertical;font-family:monospace}
    .row{display:flex;gap:8px;margin-top:8px}
    .col{flex:1}
    button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
    .muted{color:#9bb7c2;font-size:0.9rem}
    label{font-size:0.9rem;color:#9bb7c2;display:block;margin-top:10px}
    pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto}
    .status{margin-top:8px;color:#cfeee6}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PewPi — Commit files to GitHub from the browser</h1>
    <div class="muted">Paste a GitHub token, choose repo/branch/path and file contents, then Commit. WARNING: exposing tokens in the browser is insecure. Use a dedicated PAT and delete it after use.</div>

    <div class="card">
      <label>GitHub Personal Access Token (PAT)</label>
      <input id="pat" type="password" placeholder="Paste PAT here (scope: repo or public_repo)" />
      <div class="row">
        <button id="save_pat" class="secondary">Save in memory (not persistent)</button>
        <button id="clear_pat" class="secondary">Clear token</button>
      </div>
      <div class="muted">The token is kept only in JavaScript memory unless you explicitly store it. If you use the "Save to localStorage" option we will warn you. Prefer to paste each session then clear.</div>
    </div>

    <div class="card">
      <label>Repository and branch</label>
      <div class="row">
        <input id="owner" class="col" placeholder="owner (your GitHub username or org)" value="" />
        <input id="repo" class="col" placeholder="repo name" value="" />
      </div>
      <div class="row">
        <input id="branch" class="col" placeholder="branch (eg. main)" value="main" />
        <input id="filepath" class="col" placeholder="file path to create/update (eg. rogers_logic.py)" value="rogers_logic.py" />
      </div>
    </div>

    <div class="card">
      <label>Commit message</label>
      <input id="commit_msg" placeholder="Commit message" value="Update via browser commit" />

      <label>File contents (what you want to write into the repo file)</label>
      <textarea id="file_content" placeholder="Paste the file contents here (e.g. rogers_logic.py)"></textarea>

      <div class="row" style="margin-top:10px">
        <button id="check_exists">Check file exists</button>
        <button id="preview_b64" class="secondary">Preview base64</button>
        <button id="commit_btn">Commit to GitHub</button>
      </div>

      <div class="status" id="action_status"></div>

      <label style="margin-top:12px">API result</label>
      <pre id="api_result">{ no action yet }</pre>
    </div>

    <div class="card muted">
      After commit: remove or revoke the PAT. If you accidentally exposed it, revoke it immediately at https://github.com/settings/tokens
    </div>
  </div>

  <script>
  // Minimal browser GitHub commit helper
  (function(){
    // In-memory token only (unless user stores to localStorage)
    let token = null;

    const el = id;
    function id(n){ return document.getElementById(n); }

    // Save token in memory only
    el('save_pat').addEventListener('click', ()=>{
      const t = el('pat').value.trim();
      if(!t) return alert('Paste PAT first');
      token = t;
      el('action_status').textContent = 'Token loaded into memory (not persisted).';
    });

    el('clear_pat').addEventListener('click', ()=>{
      token = null;
      el('pat').value = '';
      el('action_status').textContent = 'Token cleared from memory and input.';
    });

    // Helper: base64 encode file content
    function toBase64(str){
      // btoa works on binary string; ensure proper utf8 handling:
      try {
        return btoa(unescape(encodeURIComponent(str)));
      } catch(e){
        // fallback: use browser TextEncoder -> array -> btoa
        const u = new TextEncoder().encode(str);
        let s = '';
        for(let i=0;i<u.length;i++) s += String.fromCharCode(u[i]);
        return btoa(s);
      }
    }

    // Get file SHA if exists (needed for updates). Returns {sha,exists,content}
    async function getFileSha(owner, repo, path, branch){
      const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
      const r = await fetch(url, {
        method: 'GET',
        headers: token ? { 'Authorization': 'Bearer ' + token, 'Accept': 'application/vnd.github.v3+json' } : { 'Accept': 'application/vnd.github.v3+json' }
      });
      if(r.status === 404) return { exists:false };
      const j = await r.json();
      if(r.ok){
        return { exists:true, sha: j.sha, content: j.content, download_url: j.download_url };
      } else {
        throw new Error('Error checking file: ' + (j && j.message ? j.message : r.status));
      }
    }

    // Commit (create or update)
    async function commitFile({ owner, repo, branch, path, message, contentBase64, sha }){
      const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}`;
      const body = {
        message: message || 'Update via browser',
        content: contentBase64,
        branch: branch || 'main'
      };
      if(sha) body.sha = sha;
      const r = await fetch(url, {
        method: 'PUT',
        headers: {
          'Authorization': 'Bearer ' + token,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });
      const j = await r.json();
      return { ok: r.ok, status: r.status, json: j };
    }

    // Click handlers
    el('check_exists').addEventListener('click', async ()=>{
      clearResult();
      try {
        ensureToken();
        const owner = el('owner').value.trim();
        const repo = el('repo').value.trim();
        const branch = el('branch').value.trim() || 'main';
        const path = el('filepath').value.trim();
        if(!owner||!repo||!path) return alert('provide owner, repo and filepath');
        el('action_status').textContent = 'Checking...';
        const info = await getFileSha(owner,repo,path,branch);
        if(!info.exists){
          el('action_status').textContent = 'File does NOT exist (will be created).';
          el('api_result').textContent = JSON.stringify(info,null,2);
        } else {
          el('action_status').textContent = 'File exists; sha found.';
          el('api_result').textContent = JSON.stringify({sha:info.sha, download_url: info.download_url},null,2);
        }
      } catch(e){
        el('action_status').textContent = 'Error: ' + e.message;
        el('api_result').textContent = (e.stack || e.message || String(e));
      }
    });

    el('preview_b64').addEventListener('click', ()=>{
      const content = el('file_content').value || '';
      el('api_result').textContent = toBase64(content).slice(0,400) + (content.length>200 ? '... (truncated)' : '');
    });

    el('commit_btn').addEventListener('click', async ()=>{
      clearResult();
      try {
        ensureToken();
        const owner = el('owner').value.trim();
        const repo = el('repo').value.trim();
        const branch = el('branch').value.trim() || 'main';
        const path = el('filepath').value.trim();
        const message = el('commit_msg').value.trim() || 'Update via browser commit';
        const content = el('file_content').value || '';
        if(!owner||!repo||!path) return alert('set owner, repo and filepath');
        el('action_status').textContent = 'Checking existing file...';
        const info = await getFileSha(owner,repo,path,branch);
        const base64 = toBase64(content);
        el('action_status').textContent = 'Committing... (may take a few seconds)';
        let resp;
        if(info.exists){
          resp = await commitFile({ owner, repo, branch, path, message, contentBase64: base64, sha: info.sha });
        } else {
          resp = await commitFile({ owner, repo, branch, path, message, contentBase64: base64 });
        }
        if(resp.ok){
          el('action_status').textContent = 'Commit successful: ' + (resp.json && resp.json.commit ? resp.json.commit.sha : 'ok');
          el('api_result').textContent = JSON.stringify(resp.json, null, 2);
        } else {
          el('action_status').textContent = 'Commit failed: ' + resp.status;
          el('api_result').textContent = JSON.stringify(resp.json, null, 2);
        }
      } catch(e){
        el('action_status').textContent = 'Error: ' + (e.message || e);
        el('api_result').textContent = (e.stack || e.message || String(e));
      }
    });

    function clearResult(){
      el('action_status').textContent = '';
      el('api_result').textContent = '{ no action yet }';
    }

    function ensureToken(){
      if(!token){
        const t = el('pat').value.trim();
        if(!t) throw new Error('Token not loaded. Paste your PAT and click Save in memory.');
        token = t;
      }
    }

    // Quick demo helper: prefill basic rogers_logic.py minimal content if user wants a starting file
    // (You can replace this content with the real code you want to commit.)
    const sample = `# Minimal rogers_logic.py example
import requests, re

def handle_query(q, provided_token=None):
    m = re.match(r'^fetch\\s+github\\s+([^\\s\\/]+)\\s+([^\\s\\/]+)\\s+([^\\s].*?)(?:\\s+([^\\s]+))?$', q, re.I)
    if m:
        owner, repo, path, ref = m.group(1), m.group(2), m.group(3), (m.group(4) or None)
        headers = {}
        if provided_token:
            headers['Authorization'] = 'token ' + provided_token
        # Try raw first
        for r in ([ref] if ref else ['main','master']):
            url = f"https://raw.githubusercontent.com/{owner}/{repo}/{r}/{path}"
            resp = requests.get(url, headers=headers, timeout=10)
            if resp.status_code == 200:
                return resp.text
        # fallback
        return f"Unable to fetch {owner}/{repo}/{path}"
    return f"Rogers received: {q}"
`;
    // Prefill file_content with sample if empty
    if(!el('file_content').value) el('file_content').value = sample;

  })();
  </script>
</body>
</html>