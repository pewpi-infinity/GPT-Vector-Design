<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Rogers AI Console — Diagnostic</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Inter, system-ui, Arial; background:#0d1117; color:#c9d1d9; margin:0; padding:18px; display:flex; justify-content:center; }
    .container { width:100%; max-width:900px; background:#161b22; border-radius:12px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.6); }
    #chat-window { height:46vh; overflow:auto; background:#0d1117; border-radius:8px; padding:10px; border:1px solid #30363d; }
    .message { margin-bottom:8px; padding:10px 14px; border-radius:10px; max-width:82%; word-wrap:break-word; }
    .user-message { background:#21262d; margin-left:auto; border:1px solid #30363d; }
    .rogers-message { background:#0d1117; border:1px solid #30363d; }
    .status-indicator { padding:6px 12px; border-radius:9999px; font-weight:700; font-size:.875rem; text-align:center; }
    .status-offline { background:#da3633; color:#fff; }
    .status-online { background:#3fb950; color:#000; }
    .diag { margin-top:12px; background:#0b0f14; padding:12px; border-radius:8px; border:1px solid #23303a; color:#c7d1d9; font-family:monospace; font-size:13px; white-space:pre-wrap; max-height:220px; overflow:auto; }
    input[type=text] { background:#0d1117; color:#c9d1d9; border-radius:8px; border:1px solid #2b343a; padding:10px; }
    .btn { background:#2563eb; color:#fff; padding:8px 12px; border-radius:8px; border:0; cursor:pointer; }
    .small { font-size:12px; color:#9aa6b2; }
  </style>
</head>
<body>
  <div class="container" id="app-root">
    <div class="flex justify-between items-center border-b pb-3 border-[#30363d]">
      <h1 class="text-2xl font-bold text-blue-400">Rogers AI Console</h1>
      <div id="status" class="status-indicator status-offline">OFFLINE (Connecting...)</div>
    </div>

    <div id="chat-window"></div>

    <div class="flex gap-3 mt-3">
      <input id="user-input" type="text" placeholder="Type your message..." disabled class="flex-grow" />
      <button id="send-button" class="btn" disabled>Send</button>
      <button id="check-button" class="btn">Check Status</button>
    </div>

    <div class="flex gap-3 items-center mt-3">
      <div class="small">Server URL:</div>
      <input id="server-url-input" type="text" style="width:420px" />
      <button id="save-url" class="btn">Save</button>
      <label class="small" title="Force enable controls for testing"><input id="force-enable" type="checkbox"/> Force enable</label>
      <label class="small" title="Play bot reply using device TTS (if available)"><input id="tts-toggle" type="checkbox"/> TTS</label>
    </div>

    <div class="small mt-2">Note: If this page is loaded over HTTPS (GitHub Pages), your API must also be HTTPS to avoid Mixed Content blocking.</div>

    <h3 style="color:#cfe8c3; margin-top:12px">Diagnostics</h3>
    <div id="diag" class="diag">No diagnostics yet.</div>
  </div>

  <script>
  (function(){
    const serverInput = document.getElementById('server-url-input');
    const statusEl = document.getElementById('status');
    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const checkButton = document.getElementById('check-button');
    const diag = document.getElementById('diag');
    const ttsToggle = document.getElementById('tts-toggle');
    const forceToggle = document.getElementById('force-enable');
    const saveUrlBtn = document.getElementById('save-url');

    let server = localStorage.getItem('rogers_server') || 'http://100.118.99.166:5000';
    serverInput.value = server;

    // single source-of-truth
    let isServerOnline = false;
    let announcedOnline = false; // only announce "System is online" once per transition
    let lastKnownState = null; // null, true, false

    function log(msg) { diag.textContent = new Date().toISOString() + ' — ' + msg + '\n\n' + diag.textContent; }

    function updateStatusUI(online, message) {
      // Only update UI when the state changes OR a custom message is given
      const stateChanged = lastKnownState !== online;
      lastKnownState = online;

      statusEl.textContent = message || (online ? 'ONLINE' : 'OFFLINE');
      statusEl.className = 'status-indicator ' + (online ? 'status-online' : 'status-offline');

      // compute effective enabled state respecting the force toggle
      const forced = forceToggle.checked;
      const enabled = forced ? true : online;

      // enable/disable controls
      if (userInput) userInput.disabled = !enabled;
      if (sendButton) sendButton.disabled = !enabled;

      // Focus the input only when it just became enabled, and only if user isn't already typing
      if (enabled && stateChanged) {
        try {
          const active = document.activeElement;
          if (active !== userInput) {
            userInput.focus();
          }
        } catch(e) { /* ignore focus errors */ }
      }
    }

    function addMessage(role, text) {
      const d = document.createElement('div');
      d.classList.add('message', role === 'user' ? 'user-message' : 'rogers-message');
      d.textContent = String(text);
      if (role === 'user') d.style.textAlign = 'right';
      chatWindow.appendChild(d);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function isMixedContent(targetUrl) {
      try { return location.protocol === 'https:' && targetUrl.startsWith('http:'); } catch(e){ return false; }
    }

    async function checkStatus() {
      log('Starting status fetch to ' + server + '/api/status');

      if (isMixedContent(server)) {
        const msg = 'MIXED-CONTENT WARNING: page loaded over HTTPS but server is HTTP. Browser will block the request.';
        log(msg);
        isServerOnline = false;
        updateStatusUI(false, 'OFFLINE (Mixed Content)');
        return;
      }

      try {
        const resp = await fetch(server + '/api/status', { method: 'GET', cache: 'no-store', mode: 'cors' });
        const text = await resp.text();
        log(`Status fetch HTTP ${resp.status}\nBody: ${text}`);
        let data = null;
        try { data = JSON.parse(text); } catch(e) { data = null; }

        if (resp.ok && data && data.status === 'ready') {
          // transition from offline->online should announce once
          if (!isServerOnline) {
            announcedOnline = false; // allow announcement on transition
          }
          isServerOnline = true;
          updateStatusUI(true, 'ONLINE');
          if (!announcedOnline) {
            addMessage('rogers', 'System: Rogers AI Console is online and ready.');
            announcedOnline = true;
          }
        } else {
          isServerOnline = false;
          updateStatusUI(false, 'OFFLINE (Bad Status)');
        }
      } catch (err) {
        log('Status fetch failed: ' + String(err));
        isServerOnline = false;
        updateStatusUI(false, 'OFFLINE (Network Error)');
      }
    }

    async function sendMessage() {
      const q = (userInput.value || '').trim();
      if (!q) return;
      if (!isServerOnline && !forceToggle.checked) {
        addMessage('rogers', 'Cannot send: server offline.');
        return;
      }

      addMessage('user', q);
      userInput.value = '';

      // Show sending text in status element but preserve isServerOnline state
      const prevStatusText = statusEl.textContent;
      statusEl.textContent = 'Sending...';

      try {
        const resp = await fetch(server + '/api/bot/execute', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({query: q}),
          cache:'no-store',
          mode:'cors'
        });
        const text = await resp.text();
        log(`POST /api/bot/execute HTTP ${resp.status}\nBody: ${text}`);
        let parsed = null;
        try { parsed = JSON.parse(text); } catch(e) { parsed = null; }
        const reply = parsed && parsed.ok && parsed.response ? parsed.response : (parsed && parsed.message ? parsed.message : text);
        addMessage('rogers', reply);

        // Optional TTS
        if (ttsToggle.checked && 'speechSynthesis' in window) {
          try { const u = new SpeechSynthesisUtterance(reply); window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); } catch(e) { log('TTS error: ' + e); }
        }
      } catch (err) {
        log('Send error: ' + String(err));
        addMessage('rogers', 'Critical Network Failure: Could not execute bot.');
      } finally {
        // restore status text and then re-check status
        statusEl.textContent = prevStatusText;
        await checkStatus();
      }
    }

    // Bindings
    checkButton.addEventListener('click', checkStatus);
    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });
    forceToggle.addEventListener('change', () => updateStatusUI(isServerOnline, statusEl.textContent));
    saveUrlBtn.addEventListener('click', () => {
      const v = (serverInput.value || '').trim();
      if (!v) return alert('Enter a server URL (http(s)://...)');
      server = v;
      localStorage.setItem('rogers_server', server);
      log('Server URL saved: ' + server);
      checkStatus();
    });

    // Start initial check and poll every 5 seconds
    setTimeout(() => {
      checkStatus();
      setInterval(checkStatus, 5000);
    }, 50);

    // initialize UI (will be updated by checkStatus)
    updateStatusUI(false, 'Connecting...');

    // Expose for debug
    window.__rogers_diag = { checkStatus, sendMessage, addMessage, log };

  })();
  </script>
</body>
</html>