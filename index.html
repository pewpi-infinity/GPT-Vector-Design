<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PewPi — Decrypt committed secrets</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#071722;color:#e9fbff}
    .wrap{max-width:980px;margin:0 auto}
    h1{margin:0 0 10px 0}
    .card{background:#08242f;padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
    input,textarea,select,button{font:inherit}
    input,select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#03141a;color:#e9fbff}
    textarea{min-height:140px;resize:vertical;font-family:monospace}
    .row{display:flex;gap:8px;margin-top:8px}
    .col{flex:1}
    button{background:#16b07a;border:none;padding:8px 12px;border-radius:8px;color:#00221a;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#bcdadf}
    .muted{color:#9bb7c2;font-size:0.9rem}
    label{font-size:0.9rem;color:#9bb7c2;display:block;margin-top:10px}
    pre{background:#021418;padding:8px;border-radius:8px;color:#cfeee6;overflow:auto;max-height:420px}
    .status{margin-top:8px;color:#cfeee6}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PewPi — Fetch & Decrypt Committed Secrets</h1>

    <div class="card">
      <div class="muted">This tool fetches the encrypted blob you've committed (pewpi_secrets.json), decrypts it in your browser using the passphrase you supply, and shows the plaintext. The passphrase is never sent anywhere. If the blob contains a github_token you can choose to load it into this page's sessionStorage for immediate use. Do NOT commit passphrases or plaintext tokens to the repo.</div>
    </div>

    <div class="card">
      <label>Repository (where the encrypted blob is committed)</label>
      <div class="row">
        <input id="owner" class="col" placeholder="owner (username or org)" value="pewpi-infinity" />
        <input id="repo" class="col" placeholder="repo name" value="" />
      </div>
      <div class="row">
        <input id="branch" class="col" placeholder="branch (eg. main)" value="main" />
        <input id="path" class="col" placeholder="path to blob (eg. pewpi_secrets.json)" value="pewpi_secrets.json" />
      </div>

      <label style="margin-top:10px">Passphrase (used to decrypt the blob)</label>
      <input id="passphrase" type="password" placeholder="Enter passphrase used when creating the blob" />

      <div class="row" style="margin-top:8px">
        <button id="fetch_decrypt">Fetch & Decrypt</button>
        <button id="clear_output" class="secondary">Clear</button>
      </div>

      <div id="status" class="status">Ready.</div>

      <label style="margin-top:10px">Decrypted JSON (if passphrase is correct)</label>
      <pre id="plaintext">{ nothing decrypted yet }</pre>

      <div style="margin-top:8px" class="row">
        <button id="load_token" class="secondary">Load github_token into session (if present)</button>
        <button id="copy_plain" class="secondary">Copy plaintext</button>
      </div>
    </div>

    <div class="card">
      <label>Use decrypted token with the page</label>
      <div class="muted">If you load the github_token into sessionStorage it will be used by other UI actions on this page (for example, committing or fetching files). Loading places the token only in this browser session.</div>
      <div id="token_status" class="status">No token loaded in session.</div>
    </div>
  </div>

  <script>
  // Utilities: base64 helpers and WebCrypto PBKDF2/AES-GCM decryption
  function id(n){ return document.getElementById(n); }
  function setStatus(s){ id('status').textContent = s; }
  function b64ToU8(s){
    // atob may throw on unicode; use decode fallback
    try{
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i);
      return u;
    }catch(e){
      // fallback: decode utf8-safe
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i);
      return u;
    }
  }

  async function deriveKey(pass, saltU8){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
    return crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt: saltU8, iterations: 250000, hash: 'SHA-256' },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['decrypt']
    );
  }

  async function decryptBlobObject(blobJson, passphrase){
    if(!blobJson || !blobJson.ct) throw new Error('Invalid blob format');
    // parse base64 fields
    const saltU8 = b64ToU8(blobJson.salt);
    const ivU8   = b64ToU8(blobJson.iv);
    const ctU8   = b64ToU8(blobJson.ct);
    // derive key
    const key = await deriveKey(passphrase, saltU8);
    // decrypt using AES-GCM; WebCrypto expects ciphertext+tag together (our JS encryption produced that)
    try{
      const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, key, ctU8.buffer);
      const dec = new TextDecoder().decode(pt);
      return JSON.parse(dec);
    } catch(e){
      throw new Error('Decrypt failed: ' + (e && e.message ? e.message : e));
    }
  }

  // Fetch the committed blob via raw.githubusercontent.com
  async function fetchBlobRaw(owner, repo, branch, path){
    const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(branch)}/${path}`;
    // raw.githubusercontent.com generally allows CORS; if not, user must open through GitHub UI and copy
    const r = await fetch(rawUrl, { cache: 'no-store' });
    if(!r.ok) throw new Error('Fetch failed: ' + r.status + ' ' + r.statusText);
    const text = await r.text();
    return text;
  }

  // Main handler
  id('fetch_decrypt').addEventListener('click', async ()=>{
    const owner = id('owner').value.trim();
    const repo = id('repo').value.trim();
    const branch = id('branch').value.trim() || 'main';
    const path = id('path').value.trim() || 'pewpi_secrets.json';
    const pass = id('passphrase').value;
    id('plaintext').textContent = '{ decrypting... }';
    setStatus('Fetching blob from repo...');
    if(!owner || !repo){ setStatus('owner and repo required'); return; }
    if(!pass){ setStatus('Enter passphrase to decrypt'); return; }
    try{
      const raw = await fetchBlobRaw(owner, repo, branch, path);
      // try to parse as JSON; the blob should be the ciphertext JSON
      let blob;
      try{ blob = JSON.parse(raw); }
      catch(e){
        // sometimes raw contains markdown or extra; try to extract first JSON object
        const m = raw.match(/\{[\s\S]*\}/);
        if(m) blob = JSON.parse(m[0]);
        else throw new Error('Could not parse blob JSON');
      }
      setStatus('Decrypting blob in browser (passphrase NEVER leaves your device)...');
      const plain = await decryptBlobObject(blob, pass);
      id('plaintext').textContent = JSON.stringify(plain, null, 2);
      setStatus('Decryption succeeded. You may Load token into session if secrets.github_token exists.');
    }catch(err){
      id('plaintext').textContent = '{ decryption failed }';
      setStatus('Error: ' + (err && err.message ? err.message : String(err)));
    }
  });

  id('clear_output').addEventListener('click', ()=>{
    id('plaintext').textContent = '{ nothing decrypted yet }';
    id('passphrase').value = '';
    setStatus('Cleared.');
  });

  // Copy plaintext to clipboard
  id('copy_plain').addEventListener('click', async ()=>{
    const txt = id('plaintext').textContent;
    try{ await navigator.clipboard.writeText(txt); setStatus('Plaintext copied to clipboard (be careful).'); }
    catch(e){ setStatus('Copy failed: ' + (e && e.message)); }
  });

  // Load github_token into sessionStorage for this page to use
  id('load_token').addEventListener('click', ()=>{
    try{
      const txt = id('plaintext').textContent;
      if(!txt || txt.startsWith('{') && txt.includes('nothing')) { setStatus('No plaintext available to load'); return; }
      const j = JSON.parse(txt);
      if(j && j.secrets && j.secrets.github_token){
        sessionStorage.setItem('gh.token', j.secrets.github_token);
        id('token_status').textContent = 'github_token loaded into sessionStorage (session key: gh.token)';
        setStatus('Token loaded into session for immediate use by this page.');
      } else {
        setStatus('No secrets.github_token field found in decrypted JSON.');
      }
    }catch(e){ setStatus('Load token failed: ' + (e && e.message)); }
  });

  // Initialize
  id('token_status').textContent = sessionStorage.getItem('gh.token') ? 'Token already in session' : 'No token loaded in session.';
  setStatus('Ready. Enter repo info and passphrase, then Fetch & Decrypt.');
  </script>
</body>
</html>