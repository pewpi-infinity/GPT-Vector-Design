<script>
    const SERVER_IP = "http://100.118.99.166:5000";
    const statusElement = document.getElementById('status');
    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const serverUrlEl = document.getElementById('server-url');

    // Display the server URL in the page (so it always matches)
    if (serverUrlEl) serverUrlEl.textContent = SERVER_IP;

    // Track server availability in a single place
    let isServerOnline = false;

    // --- UI UTILITIES ---
    function addMessage(role, text) {
        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', role === 'user' ? 'user-message' : 'rogers-message');

        // Use textContent to avoid unexpected HTML rendering / injection
        msgDiv.textContent = text;

        if (role === 'user') msgDiv.style.textAlign = 'right';
        chatWindow.appendChild(msgDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function setStatus(isOnline, message) {
        // Keep the single source of truth
        isServerOnline = !!isOnline;

        // Update text and classes
        statusElement.textContent = message;
        statusElement.className = 'status-indicator'; // reset classes
        statusElement.classList.add(isOnline ? 'status-online' : 'status-offline');

        // Enable/disable UI based on server state
        userInput.disabled = !isServerOnline;
        sendButton.disabled = !isServerOnline;

        if (isServerOnline) {
            userInput.focus();
        }
    }

    // --- SERVER CONNECTION CHECK ---
    async function checkServerStatus() {
        // Quick UI feedback that we're attempting a connection
        setStatus(false, 'Connecting...');

        try {
            const resp = await fetch(`${SERVER_IP}/api/status`, {
                method: 'GET',
                cache: 'no-store',
                mode: 'cors' // explicit CORS mode
            });

            if (!resp.ok) {
                // HTTP error (404, 500, etc.)
                setStatus(false, `OFFLINE (HTTP ${resp.status})`);
                console.warn('Status check HTTP error', resp.status);
                return false;
            }

            // Try to parse JSON safely
            let data;
            try {
                data = await resp.json();
            } catch (parseErr) {
                console.error('Failed to parse /api/status JSON', parseErr);
                setStatus(false, 'OFFLINE (Bad JSON)');
                return false;
            }

            // The server's payload is expected to include { status: 'ready' }
            if (data && data.status === 'ready') {
                // Server ready -> enable UI
                setStatus(true, 'ONLINE');
                addMessage('rogers', 'System: Rogers AI Console is online and ready.');
                return true;
            } else {
                setStatus(false, 'OFFLINE (Bad Status)');
                console.warn('/api/status returned unexpected payload', data);
                return false;
            }
        } catch (err) {
            // Network / CORS / other fetch errors
            console.error('Network error while checking server status', err);
            setStatus(false, 'OFFLINE (Network Error)');
            return false;
        }
    }

    // Run an initial check, then poll every 5s (adjust interval as needed)
    async function startStatusPolling() {
        await checkServerStatus();
        setInterval(checkServerStatus, 5000);
    }

    // --- MESSAGE SENDING ---
    async function sendMessage() {
        const query = userInput.value.trim();
        if (!query) return;

        // Do not attempt to send if server is known offline
        if (!isServerOnline) {
            addMessage('rogers', 'Cannot send: server is offline.');
            return;
        }

        // Show the user's message
        addMessage('user', query);
        userInput.value = '';

        // Give user feedback while the request is in flight
        setStatus(false, 'Sending...');

        try {
            const response = await fetch(`${SERVER_IP}/api/bot/execute`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: query }),
                cache: 'no-store',
                mode: 'cors'
            });

            if (!response.ok) {
                addMessage('rogers', `Critical Error: Server returned ${response.status}.`);
                // Re-check status right away; maybe server went down mid-request
                await checkServerStatus();
                return;
            }

            let result;
            try {
                result = await response.json();
            } catch (err) {
                console.error('Failed to parse response from /api/bot/execute', err);
                addMessage('rogers', 'Error: Bad JSON response from server.');
                return;
            }

            if (result && result.ok && result.response) {
                addMessage('rogers', result.response);
            } else {
                addMessage('rogers', `Error: Bot failed. ${result && result.message ? result.message : 'Unknown error.'}`);
            }

            // If everything succeeded, ensure the UI reflects the server still being online
            if (await checkServerStatus()) {
                setStatus(true, 'ONLINE');
            }
        } catch (error) {
            console.error('Network error while sending message', error);
            addMessage('rogers', 'Critical Network Failure: Could not execute bot.');
            // re-check server status
            await checkServerStatus();
        }
    }

    // Event listeners
    userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !userInput.disabled) {
            sendMessage();
        }
    });

    // Start polling after DOM is ready
    document.addEventListener('DOMContentLoaded', startStatusPolling);

    // expose function for inline onclick (if you keep it)
    window.sendMessage = sendMessage;
</script>