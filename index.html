<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PewPi — Unified Portal (single-file)</title>
<style>
  :root{
    --bg:#071722; --card:#08242f; --muted:#9bb7c2; --accent:#16b07a; --panel:#041016;
    --purple:#b695ff; --green:#75e39a; --red:#ff8b8b; --blue:#8fd1ff; --orange:#ffb06b; --yellow:#fff28f;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e9fbff}
  header{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:1.05rem}
  .topbar{display:flex;gap:8px;align-items:center}
  .nav-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
  .nav-btn.active{background:var(--accent);color:#00221a;border-color:transparent}
  .wrap{display:flex;gap:16px;padding:12px;box-sizing:border-box;height:calc(100% - 56px)}
  .left{flex:1;overflow:auto}
  .right{width:420px;min-width:260px;overflow:auto}
  .card{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-bottom:12px}
  input,textarea,select,button{font:inherit;background:#03141a;color:#e9fbff;border-radius:8px;border:1px solid rgba(255,255,255,0.04);padding:8px}
  textarea{min-height:100px;resize:vertical;font-family:monospace}
  .row{display:flex;gap:8px;margin-top:8px}
  .console{background:var(--panel);padding:10px;border-radius:8px;min-height:120px;white-space:pre-wrap;overflow:auto;color:#cfeee6}
  .tiny{font-size:0.85rem;color:var(--muted)}
  .words{line-height:1.6;font-size:1.05rem}
  .word{cursor:pointer;padding:2px 4px;border-radius:4px;text-decoration:none}
  .word.purple{color:var(--purple)}
  .word.green{color:var(--green)}
  .word.red{color:var(--red)}
  .word.blue{color:var(--blue)}
  .word.orange{color:var(--orange)}
  .word.yellow{color:#222;background:var(--yellow);padding:4px;border-radius:6px}
  .btn-primary{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;color:#00221a;cursor:pointer}
  .btn-secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}
  .debug{font-family:monospace;font-size:12px;background:#021418;padding:8px;border-radius:6px;max-height:200px;overflow:auto;color:#cfeee6}
  @media(max-width:900px){ .wrap{flex-direction:column} .right{width:100%;min-width:0} }
</style>
</head>
<body>
<script>
/*
  Resilience & compatibility shim for PewPi UI
  - map token function names so all pages can call either setToken or setSessionToken
  - install delegated click/touch handlers so nav & send work even if original handlers failed to attach
  - re-enable pointer-events on likely buttons & log to in-page debug_out element
  Paste near top of index.html (right after <body>).
*/

(function(){
  // safe guard: only run once
  if(window.__pewpi_shim_installed) return;
  window.__pewpi_shim_installed = true;

  // debug logger (writes to debug box if present)
  function shimLog(msg){
    try {
      const el = document.getElementById('debug_out') || document.getElementById('pewpi_debug_out');
      const ts = new Date().toISOString().split('T')[1].slice(0,8);
      if(el) el.textContent = (el.textContent && el.textContent.indexOf('{ no') === -1 ? el.textContent + '\n' : '') + '['+ts+'] ' + msg;
      else console.log('[pewpi-shim] ' + msg);
    } catch(e) { console.log('[pewpi-shim] ' + msg); }
  }

  // Token API compatibility: if shared helper exposes one name, create aliases
  function ensureTokenAPI(){
    try{
      // if core provides setToken, alias setSessionToken and setSessionToken
      if(window.PewPi && typeof window.PewPi.setToken === 'function'){
        if(!window.PewPi.setSessionToken) {
          window.PewPi.setSessionToken = window.PewPi.setToken;
          shimLog('Aliased PewPi.setSessionToken -> PewPi.setToken');
        }
        if(!window.PewPi.setSessionTokenShim) {
          window.PewPi.setSessionTokenShim = window.PewPi.setToken; // extra alias
        }
      }
      // if page code defines setSessionToken but PewPi lacks setToken, alias globally
      if(typeof window.setSessionToken === 'function' && !(window.PewPi && window.PewPi.setToken)){
        window.PewPi = window.PewPi || {};
        if(!window.PewPi.setToken) {
          window.PewPi.setToken = window.setSessionToken;
          shimLog('Aliased global setSessionToken -> PewPi.setToken');
        }
      }
      // create safe wrappers on window for either name
      if(!window.setToken) window.setToken = function(t){ try{ if(window.PewPi && typeof window.PewPi.setToken==='function') return window.PewPi.setToken(t); sessionStorage.setItem('gh.token', t); }catch(e){ shimLog('setToken wrapper err: '+e.message); } };
      if(!window.setSessionToken) window.setSessionToken = function(t){ try{ if(window.PewPi && typeof window.PewPi.setSessionToken==='function') return window.PewPi.setSessionToken(t); return window.setToken(t); }catch(e){ shimLog('setSessionToken wrapper err: '+e.message); } };
    }catch(e){ shimLog('ensureTokenAPI error: ' + (e && e.message)); }
  }

  // Re-enable pointer events on visible buttons to avoid CSS blocking
  function enableButtons(){
    try{
      const buttons = Array.from(document.querySelectorAll('button, .nav-btn, .btn-primary, .btn-secondary'));
      buttons.forEach(b => { try{ b.disabled = false; b.style.pointerEvents = 'auto'; b.style.opacity = ''; }catch(_){} });
      shimLog('Enabled pointer-events on ' + buttons.length + ' buttons');
    }catch(e){ shimLog('enableButtons error: '+e.message); }
  }

  // Delegated nav/send handler (listens on document so it works even if original handlers not attached)
  function installDelegation(){
    try{
      if(window.__pewpi_delegate_installed) return;
      window.__pewpi_delegate_installed = true;

      document.addEventListener('click', function(ev){
        try{
          const nav = ev.target.closest && ev.target.closest('[data-view], .nav-btn');
          if(nav && (nav.dataset && nav.dataset.view || nav.getAttribute('data-view'))){
            ev.preventDefault();
            const view = nav.dataset ? nav.dataset.view : nav.getAttribute('data-view');
            // hide all views and show requested (works with your class 'view' and id 'view_NAME')
            document.querySelectorAll('.view').forEach(v => v.style.display = 'none');
            const el = document.getElementById('view_' + view);
            if(el){ el.style.display = 'block'; }
            // active styling
            document.querySelectorAll('.nav-btn').forEach(b => b.classList && b.classList.remove('active'));
            if(nav.classList) nav.classList.add('active');
            shimLog('Delegated nav -> ' + view);
            return;
          }

          const send = ev.target.closest && ev.target.closest('#portal_send, button#portal_send, .btn-primary#portal_send');
          if(send){
            ev.preventDefault();
            const qEl = document.getElementById('portal_query') || document.getElementById('query');
            const consoleEl = document.getElementById('portal_console') || document.getElementById('console');
            const q = qEl ? (qEl.value || '').trim() : '';
            if(!q){ shimLog('Delegated send: empty query'); return; }
            shimLog('Delegated send: ' + q);
            (async ()=>{
              try{
                if(typeof rogersRespond === 'function'){
                  const resp = await rogersRespond(q);
                  if(consoleEl){
                    consoleEl.textContent += (consoleEl.textContent?'\n':'') + 'You: ' + q + '\nRogers: ' + resp;
                    consoleEl.scrollTop = consoleEl.scrollHeight;
                  } else {
                    alert('Rogers: ' + resp);
                  }
                } else {
                  // fallback echo
                  if(consoleEl){ consoleEl.textContent += (consoleEl.textContent?'\n':'') + 'You: ' + q + '\nRogers: (no handler)'; consoleEl.scrollTop = consoleEl.scrollHeight; }
                  else alert('Rogers: (no handler)');
                }
              }catch(err){
                shimLog('Delegated send error: ' + (err && err.message ? err.message : err));
                alert('Send error: ' + (err && err.message ? err.message : err));
              }
            })();
            return;
          }
        }catch(e){ shimLog('delegation outer error: ' + (e && e.message)); }
      }, false);

      // also add touchstart for mobile responsiveness
      document.addEventListener('touchstart', function(ev){
        try{
          const nav = ev.target.closest && ev.target.closest('[data-view], .nav-btn');
          if(nav){ ev.preventDefault(); nav.click(); }
        }catch(e){}
      }, { passive:false });

      shimLog('Delegation handlers installed');
    }catch(e){ shimLog('installDelegation error: '+e.message); }
  }

  // Run everything now and also after a short delay in case page loads more scripts
  try{
    ensureTokenAPI();
    enableButtons();
    installDelegation();
    setTimeout(function(){ enableButtons(); installDelegation(); ensureTokenAPI(); }, 700);
    setTimeout(function(){ enableButtons(); installDelegation(); ensureTokenAPI(); }, 2500);
  }catch(e){ shimLog('startup error: ' + (e && e.message)); }
})();
</script>
<header>
  <div>
    <h1>PewPi</h1>
    <div class="tiny">Unified Portal</div>
  </div>
  <div style="flex:1"></div>
  <nav class="topbar" aria-label="Main navigation">
    <button class="nav-btn active" data-view="portal" id="nav_portal">Portal</button>
    <button class="nav-btn" data-view="admin" id="nav_admin">Admin</button>
    <button class="nav-btn" data-view="bots" id="nav_bots">Bots</button>
    <button class="nav-btn" data-view="logs" id="nav_logs">Logs</button>
    <button class="nav-btn" data-view="terminal" id="nav_terminal">Terminal</button>
  </nav>
</header>

<div class="wrap">
  <div class="left">
    <!-- Portal -->
    <section class="card view" id="view_portal">
      <label><strong>Main Portal</strong></label>
      <div class="tiny">Click a colored word to act. Yellow words launch the App Builder.</div>

      <div style="margin-top:10px" class="card">
        <label>Interactive Sentence</label>
        <div class="words" id="words_area">
          <span class="word purple" data-status="purple" data-key="purple">Purple</span> are integrated.
          <span class="word green" data-status="green" data-key="green">Green</span> are ready.
          <span class="word red" data-status="red" data-key="red">Red</span> indicate errors.
          <span class="word blue" data-status="blue" data-key="blue">Blue</span> await info.
          <span class="word orange" data-status="orange" data-key="orange">Orange</span> are risky.
          <span class="word yellow" data-status="yellow" data-key="maps">Maps</span> produce value.
        </div>
      </div>

      <div class="card">
        <label>Portal Chat</label>
        <div id="portal_console" class="console">Rogers: ready.</div>
        <div class="row" style="margin-top:8px">
          <input id="portal_query" placeholder='Type "fetch github owner repo path" or "hello"' />
          <button class="btn-primary" id="portal_send">Send</button>
        </div>
      </div>
    </section>

    <!-- Bots -->
    <section class="card view" id="view_bots" style="display:none">
      <label><strong>Bot Farm</strong></label>
      <div class="tiny">Create browser bots. Child spawn requires approval.</div>
      <div class="row">
        <input id="bot_name" placeholder="bot name" />
        <select id="bot_type"><option value="echo">echo</option><option value="transform">transform</option><option value="fetch_github">fetch_github</option></select>
        <button class="btn-primary" id="create_bot">Create</button>
      </div>
      <div id="bots_list" style="margin-top:12px"></div>
    </section>

    <!-- Logs -->
    <section class="card view" id="view_logs" style="display:none">
      <label><strong>Logs & Activity</strong></label>
      <div id="log_view" class="console">{ no events }</div>
      <div class="row" style="margin-top:8px">
        <input id="log_pass" type="password" placeholder="Encryption passphrase (not saved)" />
        <button class="btn-primary" id="encrypt_copy">Encrypt & Copy</button>
        <button class="btn-secondary" id="encrypt_commit">Encrypt & Commit (needs PAT)</button>
      </div>
      <pre id="last_ct" style="margin-top:8px;background:#021418;padding:8px;border-radius:6px;color:#cfeee6;max-height:160px;overflow:auto">{ none }</pre>
    </section>

    <!-- Terminal -->
    <section class="card view" id="view_terminal" style="display:none">
      <label><strong>Terminal / Commits</strong></label>
      <div class="tiny">Load PAT in Admin first to commit encrypted content.</div>
      <label>Owner / Repo</label>
      <div class="row"><input id="commit_owner" placeholder="owner" /><input id="commit_repo" placeholder="repo" /></div>
      <label>Branch / Path</label>
      <div class="row"><input id="commit_branch" placeholder="branch" value="main" /><input id="commit_path" placeholder="path (eg. logs.json)" /></div>
      <label>Message</label><input id="commit_msg" placeholder="Commit message" value="Add encrypted log" />
      <label>Content (paste ciphertext JSON)</label><textarea id="commit_content"></textarea>
      <div class="row" style="margin-top:8px"><button class="btn-primary" id="do_commit">Commit</button><button class="btn-secondary" id="check_file">Check Exists</button></div>
      <pre id="terminal_out" class="console" style="margin-top:8px">{ terminal }</pre>
    </section>
  </div>

  <aside class="right">
    <section class="card view" id="view_admin" style="display:none">
      <label><strong>Admin / Unlock</strong></label>
      <div class="tiny">Paste ciphertext or fetch from raw GitHub and enter passphrase in "Put it here".</div>
      <label>Put it here</label>
      <div class="row">
        <input id="admin_pass" type="password" placeholder="Put it here" />
        <button class="btn-primary" id="admin_unlock">Unlock</button>
      </div>

      <label style="margin-top:8px">Ciphertext JSON (optional)</label>
      <textarea id="admin_blob" placeholder='Paste ciphertext JSON here if not embedded'></textarea>
      <div class="row" style="margin-top:8px">
        <input id="admin_rawurl" placeholder="raw.githubusercontent URL (optional)" />
        <button class="btn-secondary" id="fetch_blob">Fetch</button>
        <button class="btn-secondary" id="paste_clip">Paste clipboard</button>
      </div>

      <label style="margin-top:8px">In-memory PAT (for commits)</label>
      <div class="row">
        <input id="admin_pat" type="password" placeholder="Paste PAT here (memory only)" />
        <button class="btn-secondary" id="load_pat">Load</button>
        <button class="btn-secondary" id="clear_pat">Clear</button>
      </div>
      <div id="admin_status" class="tiny" style="margin-top:8px">No session</div>

      <label style="margin-top:8px">Decrypted preview</label>
      <pre id="admin_plain" style="max-height:160px;overflow:auto">{ none }</pre>
      <div class="row" style="margin-top:8px">
        <button class="btn-primary" id="load_token_from_plain">Load github_token into session</button>
        <button class="btn-secondary" id="re_encrypt">Re-encrypt (change passphrase)</button>
      </div>
    </section>

    <section class="card">
      <label><strong>Word Info</strong></label>
      <div id="word_info" class="tiny">Click a colored word to see info and actions.</div>
      <div style="margin-top:8px"><button class="btn-secondary" id="clear_log">Clear Session Log</button></div>
    </section>

    <section class="card">
      <label><strong>Debug</strong></label>
      <div id="debug_out" class="debug">{ no debug }</div>
    </section>
  </aside>
</div>

<script>
/* Compact, robust inline JS:
   - delegation and resilient event attachment prevent missing handlers
   - WebCrypto helpers (PBKDF2 250k + AES-GCM)
   - simple rogersRespond + GitHub fetch/commit helpers
   - debug logging visible in-page so you don't need DevTools
*/

function $(id){ return document.getElementById(id); }
function logDebug(msg){
  const el = $('debug_out');
  const ts = new Date().toISOString().split('T')[1].slice(0,8);
  el.textContent = (el.textContent && el.textContent !== '{ no debug }' ? el.textContent + '\n' : '') + `[${ts}] ${msg}`;
  el.scrollTop = el.scrollHeight;
}

/* --- minimal crypto helpers --- */
const ITER = 250000;
function u8FromB64(s){ const bin = atob(s); const u=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u[i]=bin.charCodeAt(i); return u; }
function u8ToB64(u8){ let s=''; for(let i=0;i<u8.length;i++) s+=String.fromCharCode(u8[i]); return btoa(s); }
async function deriveKey(pass, saltU8, usages=['encrypt','decrypt']){ const enc=new TextEncoder(); const base=await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2', salt: saltU8, iterations: ITER, hash: 'SHA-256'}, base, {name:'AES-GCM', length:256}, false, usages); }
async function decryptBlob(blob, pass){ if(!blob || !blob.ct) throw new Error('Invalid ciphertext blob'); const salt=u8FromB64(blob.salt), iv=u8FromB64(blob.iv), ct=u8FromB64(blob.ct); const key=await deriveKey(pass, salt, ['decrypt']); const pt=await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct.buffer); return JSON.parse(new TextDecoder().decode(pt)); }
async function encryptJSON(obj, pass){ const salt=crypto.getRandomValues(new Uint8Array(16)); const iv=crypto.getRandomValues(new Uint8Array(12)); const key=await deriveKey(pass, salt, ['encrypt']); const ct=await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, new TextEncoder().encode(JSON.stringify(obj))); return { v:1, salt:u8ToB64(salt), iv:u8ToB64(iv), ct:u8ToB64(new Uint8Array(ct)), created_at: new Date().toISOString() }; }

/* --- session & token --- */
let SESSION_LOG = [];
let INMEM_TOKEN = null;
function appendLog(entry){ SESSION_LOG.push({ ts: new Date().toISOString(), entry }); $('log_view').textContent = JSON.stringify(SESSION_LOG, null, 2); }
function setToken(t){ INMEM_TOKEN = t; try{ sessionStorage.setItem('gh.token', t); }catch(e){}; try{ const ch=new BroadcastChannel('pewpi-token'); ch.postMessage({token:t}); ch.close(); }catch(e){}; $('admin_status').textContent = 'Token loaded in session'; logDebug('Token set'); }
function clearToken(){ INMEM_TOKEN = null; try{ sessionStorage.removeItem('gh.token'); }catch(e){}; $('admin_status').textContent = 'Token cleared'; logDebug('Token cleared'); }
function getToken(){ return sessionStorage.getItem('gh.token') || INMEM_TOKEN || null; }

/* --- navigation (visible buttons) --- */
function showView(name){
  document.querySelectorAll('.view').forEach(v=>v.style.display='none');
  const el = $('view_' + name);
  if(el) el.style.display = 'block';
  document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active'));
  const btn = document.querySelector('.nav-btn[data-view="'+name+'"]');
  if(btn) btn.classList.add('active');
  logDebug('Switched view: ' + name);
}
document.querySelectorAll('.nav-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> showView(btn.dataset.view));
  btn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); showView(btn.dataset.view); }, { passive:false });
});

/* --- interactive words --- */
const WORD_ACTIONS = {
  purple:{label:'Integrated', info:'Purple items integrated.'},
  green:{label:'Ready', info:'Green items ready.'},
  red:{label:'Error', info:'Red items have errors.'},
  blue:{label:'Awaiting', info:'Blue need info.'},
  orange:{label:'Risky', info:'Orange are risky.'},
  yellow:{label:'App Builder', info:'Yellow words start app builder.'}
};
function onWordClick(ev){
  const el = ev.currentTarget;
  const status = el.dataset.status;
  const key = el.dataset.key || el.textContent.trim();
  const info = WORD_ACTIONS[status] || {label:status, info:''};
  $('word_info').innerHTML = `<strong>${key}</strong><div class="tiny">${info.label}</div><div class="tiny" style="margin-top:6px">${info.info}</div>`;
  appendLog(`Word clicked: ${key} (${status})`);
  if(status === 'yellow') startAppBuilder(key);
  if(status === 'red') alert('Item marked RED (error). Check logs.');
}
function attachWordHandlers(){ document.querySelectorAll('.word').forEach(w=>{ w.removeEventListener('click', onWordClick); w.addEventListener('click', onWordClick); w.addEventListener('touchstart', ev=>{ ev.preventDefault(); onWordClick.call(w, ev); }, { passive:false }); }); }

/* --- App builder --- */
async function startAppBuilder(topic){
  if(!confirm(`Start App Builder for "${topic}"?`)){ appendLog('App builder cancelled'); return; }
  const appName = prompt('App name (short):', topic + ' App'); if(!appName){ appendLog('App builder aborted'); return; }
  const purpose = prompt('Main purpose?', 'Mapping / suggestions'); const users = prompt('Target users (comma separated)', 'me,team');
  const preview = { appName, topic, purpose, users: users?users.split(',').map(s=>s.trim()):[] , created:new Date().toISOString() };
  appendLog('APP_SCAFFOLD: ' + JSON.stringify(preview));
  alert('App scaffold created in-session. Check Logs view.');
}

/* --- Admin / decrypt --- */
$('paste_clip') && $('paste_clip').addEventListener('click', async ()=>{ try{ const t = await navigator.clipboard.readText(); $('admin_blob').value = t; $('admin_status').textContent = 'Pasted from clipboard'; }catch(e){ $('admin_status').textContent = 'Clipboard read failed'; logDebug('Clipboard read failed: ' + (e && e.message)); }});
$('fetch_blob') && $('fetch_blob').addEventListener('click', async ()=>{ const url = $('admin_rawurl').value.trim(); if(!url) return alert('Enter raw URL'); $('admin_status').textContent='Fetching...'; try{ const txt = await fetch(url,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(r.status); return r.text(); }); $('admin_blob').value = txt; $('admin_status').textContent='Fetched'; appendLog('Fetched blob'); }catch(e){ $('admin_status').textContent = 'Fetch failed: ' + e.message; logDebug('Fetch error: ' + e.stack); }});

$('admin_unlock').addEventListener('click', async ()=>{ const pass = $('admin_pass').value; let txt = $('admin_blob').value.trim(); $('admin_status').textContent='Unlocking...'; try{ if(!txt){ const saved = localStorage.getItem('pewpi_embedded_ct'); if(saved){ txt = saved; $('admin_status').textContent = 'Using saved embedded ciphertext'; } else throw new Error('No ciphertext found'); } const blob = JSON.parse(txt); const plain = await decryptBlob(blob, pass); $('admin_plain').textContent = JSON.stringify(plain, null, 2); window._decrypted_plain = plain; $('admin_status').textContent = 'Decrypted OK'; appendLog('Decryption succeeded'); if(plain && plain.secrets && plain.secrets.github_token){ setToken(plain.secrets.github_token); $('admin_status').textContent += ' — token auto-loaded'; showView('portal'); portalAnnounce('Token loaded from decrypted blob.'); } }catch(e){ $('admin_status').textContent = 'Unlock failed: ' + (e && e.message ? e.message : e); logDebug('Decrypt error: ' + (e && e.stack || e)); appendLog('Decrypt failed'); } });

$('load_pat') && $('load_pat').addEventListener('click', ()=>{ const t=$('admin_pat').value.trim(); if(!t) return alert('Paste PAT first'); setToken(t); $('admin_status').textContent='PAT loaded (in-memory)'; appendLog('PAT loaded'); });
$('clear_pat') && $('clear_pat').addEventListener('click', ()=>{ clearToken(); });

$('load_token_from_plain') && $('load_token_from_plain').addEventListener('click', ()=>{ try{ const txt = $('admin_plain').textContent; if(!txt || txt.includes('none')) return alert('Nothing decrypted'); const obj = JSON.parse(txt); if(!obj.secrets || !obj.secrets.github_token) return alert('No github_token present'); setToken(obj.secrets.github_token); $('admin_status').textContent='Token loaded from plaintext'; appendLog('Token loaded from plaintext'); }catch(e){ $('admin_status').textContent='Load failed: '+(e && e.message); logDebug('Load token from plain failed: ' + e); } });

$('re_encrypt') && $('re_encrypt').addEventListener('click', async ()=>{ try{ const plain = window._decrypted_plain; if(!plain) return alert('Decrypt first'); const newPass = prompt('Enter NEW passphrase (do NOT use PAT)'); if(!newPass) return alert('Cancelled'); const ct = await encryptJSON(plain, newPass); $('admin_blob').value = JSON.stringify(ct, null, 2); $('admin_status').textContent='Re-encrypted; paste this ciphertext into repo or save locally'; appendLog('Re-encrypted blob'); }catch(e){ $('admin_status').textContent='Re-encrypt failed: '+(e && e.message); logDebug('Re-encrypt error: '+e.stack); }});

/* --- Portal chat / rogersRespond --- */
function portalAnnounce(msg){ const c=$('portal_console'); c.textContent += (c.textContent?'\n':'') + 'System: ' + msg; c.scrollTop = c.scrollHeight; appendLog('Portal: '+msg); }
$('portal_send').addEventListener('click', async ()=>{ const q=$('portal_query').value.trim(); if(!q) return; portalLog('You: '+q); $('portal_query').value=''; portalLog('Rogers: (thinking...)'); try{ const resp = await rogersRespond(q); const c=$('portal_console'); const lines = c.textContent.split('\n'); if(lines[lines.length-1].includes('(thinking...)')) lines.pop(); c.textContent = lines.join('\n') + '\nRogers: ' + resp; c.scrollTop = c.scrollHeight; appendLog('Rogers response'); }catch(e){ portalLog('Rogers error: '+(e && e.message)); logDebug('rogersRespond error: ' + (e && e.stack)); appendLog('Rogers error'); } });
function portalLog(txt){ const c=$('portal_console'); c.textContent += (c.textContent?'\n':'') + txt; c.scrollTop = c.scrollHeight; }

/* --- fetch helpers --- */
async function fetchGithubFile(owner,repo,path,ref='main'){
  try{ const raw=`https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${path}`; const r=await fetch(raw,{cache:'no-store'}); if(r.ok) return {ok:true,text:await r.text(),source:raw}; }catch(e){}
  const token = getToken(); if(token){ const api=`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${ref}`; const r=await fetch(api,{headers:{Authorization:'Bearer '+token,Accept:'application/vnd.github.v3.raw'}}); if(r.ok) return {ok:true,text:await r.text(),source:api}; const b=await r.text().catch(()=>String(r.status)); return {ok:false,err:'GitHub API '+r.status+': '+b}; }
  return {ok:false,err:'Raw fetch failed and no token available.'};
}
async function rogersRespond(q){
  q=(q||'').trim(); if(!q) return 'Empty';
  const m=/^fetch\s+github\s+([^\s\/]+)\s+([^\s\/]+)\s+([^\s].*?)(?:\s+([^\s]+))?$/i.exec(q);